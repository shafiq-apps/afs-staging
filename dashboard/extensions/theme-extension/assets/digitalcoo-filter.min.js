"use strict";

// src/components/Icons.ts
var Icons = {
  rightArrow: '<svg xmlns="http://www.w3.org/2000/svg" width="34px" height="34px" viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.39862 4.32752C9.69152 4.03463 10.1664 4.03463 10.4593 4.32752L16.8232 10.6915C17.5067 11.3749 17.5067 12.4829 16.8232 13.1664L10.4593 19.5303C10.1664 19.8232 9.69152 19.8232 9.39863 19.5303C9.10573 19.2374 9.10573 18.7625 9.39863 18.4697L15.7626 12.1057C15.8602 12.0081 15.8602 11.8498 15.7626 11.7521L9.39863 5.38818C9.10573 5.09529 9.10573 4.62041 9.39862 4.32752Z" fill="currentColor"/></svg>',
  downArrow: '<svg xmlns="http://www.w3.org/2000/svg" width="34px" height="34px" viewBox="0 0 24 24" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.46938 9.39966C4.76227 9.10677 5.23715 9.10677 5.53004 9.39966L11.894 15.7636C11.9916 15.8613 12.1499 15.8613 12.2476 15.7636L18.6115 9.39966C18.9044 9.10677 19.3793 9.10677 19.6722 9.39966C19.9651 9.69256 19.9651 10.1674 19.6722 10.4603L13.3082 16.8243C12.6248 17.5077 11.5168 17.5077 10.8333 16.8243L4.46938 10.4603C4.17649 10.1674 4.17649 9.69256 4.46938 9.39966Z" fill="currentColor"/></svg>',
  eye: '<svg xmlns="http://www.w3.org/2000/svg" width="34px" height="34px" viewBox="0 0 32 32" fill="currentColor"><path d="M16.108 10.044c-3.313 0-6 2.687-6 6s2.687 6 6 6 6-2.686 6-6-2.686-6-6-6zM16.108 20.044c-2.206 0-4.046-1.838-4.046-4.044s1.794-4 4-4c2.206 0 4 1.794 4 4s-1.748 4.044-3.954 4.044zM31.99 15.768c-0.012-0.050-0.006-0.104-0.021-0.153-0.006-0.021-0.020-0.033-0.027-0.051-0.011-0.028-0.008-0.062-0.023-0.089-2.909-6.66-9.177-10.492-15.857-10.492s-13.074 3.826-15.984 10.486c-0.012 0.028-0.010 0.057-0.021 0.089-0.007 0.020-0.021 0.030-0.028 0.049-0.015 0.050-0.009 0.103-0.019 0.154-0.018 0.090-0.035 0.178-0.035 0.269s0.017 0.177 0.035 0.268c0.010 0.050 0.003 0.105 0.019 0.152 0.006 0.023 0.021 0.032 0.028 0.052 0.010 0.027 0.008 0.061 0.021 0.089 2.91 6.658 9.242 10.428 15.922 10.428s13.011-3.762 15.92-10.422c0.015-0.029 0.012-0.058 0.023-0.090 0.007-0.017 0.020-0.030 0.026-0.050 0.015-0.049 0.011-0.102 0.021-0.154 0.018-0.090 0.034-0.177 0.034-0.27 0-0.088-0.017-0.175-0.035-0.266zM16 25.019c-5.665 0-11.242-2.986-13.982-8.99 2.714-5.983 8.365-9.047 14.044-9.047 5.678 0 11.203 3.067 13.918 9.053-2.713 5.982-8.301 8.984-13.981 8.984z"/></svg>',
  minus: '<svg xmlns="http://www.w3.org/2000/svg" width="34px" height="34px" viewBox="0 0 20 20" fill="none"><path fill="currentColor" fill-rule="evenodd" d="M18 10a1 1 0 01-1 1H3a1 1 0 110-2h14a1 1 0 011 1z"/></svg>',
  plus: '<svg xmlns="http://www.w3.org/2000/svg" width="34px" height="34px" viewBox="0 0 20 20" fill="none"><path fill="currentColor" fill-rule="evenodd" d="M9 17a1 1 0 102 0v-6h6a1 1 0 100-2h-6V3a1 1 0 10-2 0v6H3a1 1 0 000 2h6v6z"/></svg>',
  close: '<svg xmlns="http://www.w3.org/2000/svg" width="34px" height="34px" viewBox="0 0 24 24" fill="currentColor"><path d="M19 5L4.99998 19M5.00001 5L19 19" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>'
};

// src/config/index.ts
var Config = {
  DEBOUNCE: 200,
  TIMEOUT: 1e4,
  CACHE_TTL: 3e5,
  PAGE_SIZE: 24
};

// src/locals/index.ts
var Lang = {
  buttons: {
    quickAdd: "Quick Add",
    quickAddToCart: "Quick add to cart",
    quickView: "Quick view",
    addToCart: "Add to cart",
    soldOut: "Sold out",
    buyNow: "Buy it now",
    clear: "Clear",
    clearAll: "Clear All",
    close: "\u2715",
    closeFilters: "Close filters",
    toggleFilters: "Filters",
    filters: "Filters",
    previous: "Previous",
    next: "Next",
    apply: "Apply"
  },
  labels: {
    sortBy: "Sort by: ",
    appliedFilters: "Applied Filters:",
    search: "Search: ",
    price: "Price: ",
    collection: "Collection: ",
    productUnavailable: "Product unavailable",
    loading: "Loading...",
    loadingProduct: "Loading product..."
  },
  sortOptions: {
    bestSelling: "Best Selling",
    titleAsc: "Title (A-Z)",
    titleDesc: "Title (Z-A)",
    priceAsc: "Price (Low to High)",
    priceDesc: "Price (High to Low)",
    createdAsc: "Oldest First",
    createdDesc: "Newest First"
  },
  messages: {
    noProductsFound: "No products found",
    oneProductFound: "1 product found",
    productsFound: "products found",
    showingProducts: "Showing",
    pageOf: "Page",
    addedToCart: "Added to cart!",
    failedToLoad: "Failed to load",
    failedToLoadProducts: "Failed to load products",
    failedToLoadProduct: "Failed to load product",
    failedToAddToCart: "Failed to add product to cart. Please try again.",
    failedToProceedToCheckout: "Failed to proceed to checkout. Please try again.",
    failedToLoadProductModal: "Failed to load product. Please try again.",
    failedToLoadFilters: "Failed to load filters, continuing with empty filters",
    initializationFailed: "Initialization failed",
    loadFailed: "Load failed",
    unknownError: "Unknown error",
    checkConsole: "Check console for details."
  },
  placeholders: {
    searchProducts: "Search products...",
    searchFilter: "Search"
  }
};

// src/utils/$.utils.ts
var $ = {
  // Fastest debounce
  debounce: (fn, ms) => {
    let t;
    return (...a) => {
      if (t !== void 0) clearTimeout(t);
      t = setTimeout(() => fn(...a), ms);
    };
  },
  toLowerCase: (s) => String(s || "").toLowerCase(),
  inputDisplayType: (option) => {
    return $.equalsAny($.toLowerCase(option == null ? void 0 : option.displayType), "radio" /* RADIO */) ? "radio" : "checkbox";
  },
  isMultiSelect: (option) => {
    return $.equalsAny($.toLowerCase(option == null ? void 0 : option.selectionType), "multiple" /* MULTIPLE */) || $.equalsAny(option == null ? void 0 : option.selectionType, "MULTIPLE" /* MULTIPLE_UPPER */);
  },
  // Fast array split
  split: (v) => {
    if (!v) return [];
    if (Array.isArray(v)) return v.map((s) => String(s).trim()).filter(Boolean);
    return String(v).split(",").map((s) => s.trim()).filter(Boolean);
  },
  // Fast ID getter
  id: (p) => {
    if (!p) return null;
    const id = p.productId || p.id || p.gid;
    if (!id) return null;
    return String(id).split("/").pop() || null;
  },
  // Fast string check
  str: (v) => String(v || "").trim(),
  // Fast empty check
  empty: (v) => {
    if (!v) return true;
    if (Array.isArray(v)) return v.length === 0;
    if (typeof v === "object") return Object.keys(v).length === 0;
    return false;
  },
  // Fast element creator
  el: (tag, cls, attrs = {}) => {
    const e = document.createElement(tag);
    if (cls) e.className = cls;
    Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v));
    return e;
  },
  // Fast text setter
  txt: (el, text) => {
    el.textContent = text;
    return el;
  },
  // Fast clear (replaces innerHTML)
  clear: (el) => {
    while (el.firstChild) {
      const child = el.firstChild;
      if (child) el.removeChild(child);
    }
  },
  // Fast fragment append
  frag: (items, fn) => {
    const f = document.createDocumentFragment();
    items.forEach((item) => f.appendChild(fn(item)));
    return f;
  },
  // Optimize Shopify image URL with transformations
  optimizeImageUrl: (url, options = {}) => {
    if (!url || typeof url !== "string") return "";
    const {
      width = 500,
      height = width,
      quality = 80,
      format = "webp",
      crop = null
    } = options;
    const shopifyCdnPattern = /(cdn\.shopify\.com|shopifycdn\.com)/i;
    if (!shopifyCdnPattern.test(url)) return url;
    try {
      const urlObj = new URL(url);
      const params = new URLSearchParams(urlObj.search);
      params.delete("width");
      params.delete("height");
      params.delete("crop");
      params.delete("format");
      params.delete("quality");
      params.set("width", String(width));
      params.set("height", String(height));
      if (crop) params.set("crop", crop);
      if (quality !== 100) params.set("quality", String(quality));
      const isGif = urlObj.pathname.toLowerCase().endsWith(".gif");
      if (!isGif && format) params.set("format", format);
      return `${urlObj.origin}${urlObj.pathname}?${params.toString()}`;
    } catch (err) {
      return url;
    }
  },
  // Build responsive srcset for Shopify images
  buildImageSrcset: (baseUrl, sizes = [200, 300, 500]) => {
    if (!baseUrl) return "";
    return sizes.map((size) => {
      const optimized = $.optimizeImageUrl(baseUrl, { width: size, format: "webp", quality: size <= 200 ? 75 : size <= 300 ? 80 : 85 });
      return `${optimized} ${size}w`;
    }).join(", ");
  },
  // Format money using Shopify money format
  formatMoney: (cents, moneyFormat, currency = "") => {
    if (isNaN(Number(cents))) return "";
    const amount = parseFloat(String(cents)) / 100;
    if (!moneyFormat || typeof moneyFormat !== "string") {
      return `${currency || ""}${amount.toFixed(2)}`;
    }
    let formattedAmount = amount.toFixed(2);
    if (moneyFormat.includes("{{amount_no_decimals}}")) {
      formattedAmount = Math.round(amount).toString();
      return moneyFormat.replace("{{amount_no_decimals}}", formattedAmount);
    }
    if (moneyFormat.includes("{{amount_with_comma_separator}}")) {
      formattedAmount = amount.toFixed(2).replace(".", ",");
      return moneyFormat.replace("{{amount_with_comma_separator}}", formattedAmount);
    }
    if (moneyFormat.includes("{{amount_no_decimals_with_comma_separator}}")) {
      formattedAmount = Math.round(amount).toString();
      return moneyFormat.replace("{{amount_no_decimals_with_comma_separator}}", formattedAmount);
    }
    if (moneyFormat.includes("{{amount_with_apostrophe_separator}}")) {
      formattedAmount = amount.toFixed(2).replace(".", "'");
      return moneyFormat.replace("{{amount_with_apostrophe_separator}}", formattedAmount);
    }
    return moneyFormat.replace("{{amount}}", formattedAmount);
  },
  // Reusable comparison functions
  // Compare two values (string, number, boolean, array, or object) with case-insensitive and trimmed string comparison
  equals: (a, b) => {
    if (a === b) return true;
    if (a === null || a === void 0 || b === null || b === void 0) return false;
    if (Array.isArray(a)) {
      a = a.join(",");
    }
    if (Array.isArray(b)) {
      b = b.join(",");
    }
    if (typeof a === "string" && typeof b === "string") {
      return a.trim().toLowerCase() === b.trim().toLowerCase();
    }
    if (typeof a === "number" && typeof b === "number") {
      return a === b;
    }
    if (typeof a === "boolean" && typeof b === "boolean") {
      return a === b;
    }
    return String(a).trim().toLowerCase() === String(b).trim().toLowerCase();
  },
  // Check if value equals any of the provided enum/constant values (case-insensitive, trimmed)
  equalsAny: (value, ...values) => {
    if (value === null || value === void 0) return false;
    return values.some((v) => $.equals(value, v));
  },
  // Check if a filter key matches vendor (handles 'vendor' or 'vendors')
  isVendorKey: (key) => {
    return $.equalsAny(key, "vendor" /* VENDOR */, "vendors" /* VENDORS */);
  },
  // Check if a filter key matches productType (handles 'productType' or 'productTypes')
  isProductTypeKey: (key) => {
    return $.equalsAny(key, "productType" /* PRODUCT_TYPE */, "productTypes" /* PRODUCT_TYPES */);
  },
  // Check if a filter key matches tags (handles 'tag' or 'tags')
  isTagKey: (key) => {
    return $.equalsAny(key, "tag" /* TAG */, "tags" /* TAGS */);
  },
  // Check if a filter key matches collections (handles 'collection' or 'collections')
  isCollectionKey: (key) => {
    return $.equalsAny(key, "collection" /* COLLECTION */, "collections" /* COLLECTIONS */);
  },
  // Check if a filter key matches priceRange (handles 'priceRange' or 'price')
  isPriceRangeKey: (key) => {
    return $.equalsAny(key, "priceRange" /* PRICE_RANGE */, "price" /* PRICE */);
  },
  // Check if sort field is best-selling (handles 'best-selling' or 'bestselling')
  isBestSelling: (field) => {
    return $.equalsAny(field, "best-selling" /* BEST_SELLING */, "bestselling" /* BESTSELLING */);
  },
  // Check if option type is Collection
  isCollectionOptionType: (optionType) => {
    return $.equals(optionType, "Collection" /* COLLECTION */);
  },
  // Check if option type is priceRange
  isPriceRangeOptionType: (optionType) => {
    return $.equals(optionType, "priceRange" /* PRICE_RANGE */);
  }
};

// src/utils/dom-ready.ts
function waitForElement(selector, container = document, timeout = 5e3) {
  return new Promise((resolve, reject) => {
    const existing = container.querySelector(selector);
    if (existing) {
      resolve(existing);
      return;
    }
    const timeoutId = setTimeout(() => {
      observer.disconnect();
      reject(new Error(`Element ${selector} not found within ${timeout}ms`));
    }, timeout);
    const observer = new MutationObserver((mutations, obs) => {
      const element = container.querySelector(selector);
      if (element) {
        obs.disconnect();
        clearTimeout(timeoutId);
        resolve(element);
      }
    });
    const target = container instanceof Document ? container.body : container;
    observer.observe(target, {
      childList: true,
      subtree: true
    });
  });
}
function waitForElements(selectors, container = document, timeout = 5e3) {
  return Promise.all(
    selectors.map((selector) => waitForElement(selector, container, timeout))
  );
}

// src/utils/variant-util.ts
function getSelectedOptions(dialog, optionsCount) {
  return Array.from({ length: optionsCount }, (_, i) => {
    var _a;
    const btn = dialog.querySelector(
      `.afs-product-modal__option-value[data-option-index="${i}"].afs-product-modal__option-value--selected`
    );
    return (_a = btn == null ? void 0 : btn.dataset.optionValue) != null ? _a : null;
  });
}
function findMatchingVariants(variants, selected) {
  return variants.filter(
    (v) => selected.every((val, idx) => {
      if (!val) return true;
      if (idx === 0) return v.option1 === val;
      if (idx === 1) return v.option2 === val;
      return v.option3 === val;
    })
  );
}
function isVariantAvailable(variant) {
  return variant.available !== false && variant.availableForSale !== false;
}
function isOptionValueAvailable(product, optionIndex, optionValue, selected) {
  return product.variants.some((v) => {
    const isAvailable = v.available !== false && v.availableForSale !== false;
    if (!isAvailable) return false;
    if (optionIndex === 0 && v.option1 !== optionValue || optionIndex === 1 && v.option2 !== optionValue || optionIndex === 2 && v.option3 !== optionValue) {
      return false;
    }
    return selected.every((val, idx) => {
      if (idx === optionIndex || !val) return true;
      if (idx === 0) return v.option1 === val;
      if (idx === 1) return v.option2 === val;
      return v.option3 === val;
    });
  });
}

// src/utils/shared.ts
var Log = {
  enabled: true,
  // Always enabled for debugging
  error: (msg, data) => {
    if (Log.enabled) console.error("[AFS]", msg, data || "");
  },
  warn: (msg, data) => {
    if (Log.enabled) console.warn("[AFS]", msg, data || "");
  },
  info: (msg, data) => {
    if (Log.enabled) console.info("[AFS]", msg, data || "");
  },
  debug: (msg, data) => {
    if (Log.enabled) console.debug("[AFS]", msg, data || "");
  },
  log: (msg, ...args) => {
    if (Log.enabled) console.log(msg, ...args);
  },
  init: (enabled) => {
    Log.enabled = enabled !== false;
    Log.log(
      "%cAdvanced Filter & Search initialized",
      "color: #00c853;font-size: 20px;font-weight: bold;background: #0b1e13;padding: 10px 15px;border-radius: 6px;font-family: Arial, sans-serif;"
    );
  }
};

// src/digitalcoo-filter.ts
var States = /* @__PURE__ */ new Map();
var EXCLUDED_QUERY_PARAMS = /* @__PURE__ */ new Set(["shop" /* SHOP */, "shop_domain" /* SHOP_DOMAIN */, "cpid" /* CPID */]);
var formatPrice = (value) => {
  if (typeof value !== "number" || isNaN(value)) return 0;
  return parseFloat(value.toFixed(2));
};
var Metadata = {
  // Build metadata map from filters array (for display labels, types, etc.)
  buildFilterMetadata: (filters) => {
    const m = /* @__PURE__ */ new Map();
    if (!Array.isArray(filters)) return m;
    filters.forEach((f) => {
      if (f.handle) {
        m.set(f.handle, {
          label: f.label || f.queryKey || f.optionKey || f.handle,
          queryKey: f.queryKey,
          optionKey: f.optionKey,
          optionType: f.optionType
        });
      }
    });
    return m;
  }
};
var FilterState = {
  shop: null,
  // Filters: standard filters (fixed keys) + dynamic option filters (handles as keys)
  // Example: { vendor: [], ef4gd: ["red"], pr_a3k9x: ["M"], search: '', priceRange: null }
  filters: { vendor: [], productType: [], tags: [], collections: [], search: "", priceRange: null },
  products: [],
  collections: [],
  selectedCollection: { id: null, sortBy: null },
  pagination: { page: 1, limit: Config.PAGE_SIZE, total: 0, totalPages: 0 },
  sort: { field: "best-selling", order: "asc" },
  loading: false,
  availableFilters: [],
  // Metadata maps (for display only, not for state management)
  filterMetadata: /* @__PURE__ */ new Map(),
  // handle -> { label, type, queryKey, optionKey }
  // Fallback products from Liquid (to prevent blank screen when API fails)
  fallbackProducts: [],
  // Fallback pagination from Liquid (for proper pagination controls when API fails)
  fallbackPagination: { currentPage: 1, totalPages: 1, totalProducts: 0 },
  // Flag to track if we're using fallback mode (API failed)
  usingFallback: false,
  // Money formatting from Shopify
  moneyFormat: null,
  moneyWithCurrencyFormat: null,
  currency: null,
  scrollToProductsOnFilter: false,
  // Handle-based keys for range filters (provided by server filter config)
  priceRangeHandle: null
};
var UrlManager = {
  parse() {
    const url = new URL(window.location.href);
    const params = {};
    let parsedPriceMin;
    let parsedPriceMax;
    url.searchParams.forEach((value, key) => {
      if (EXCLUDED_QUERY_PARAMS.has(key)) return;
      if ($.isVendorKey(key)) params.vendor = $.split(value);
      else if ($.isProductTypeKey(key)) params.productType = $.split(value);
      else if ($.isTagKey(key)) params.tags = $.split(value);
      else if ($.isCollectionKey(key)) params.collections = $.split(value);
      else if ($.equals(key, "search" /* SEARCH */)) params.search = value;
      else if ($.equals(key, "q")) params.search = value;
      else if ($.equals(key, "priceMin" /* PRICE_MIN */)) {
        const v = formatPrice(parseFloat(value));
        if (!isNaN(v) && v >= 0) parsedPriceMin = v;
      } else if ($.equals(key, "priceMax" /* PRICE_MAX */)) {
        const v = formatPrice(parseFloat(value));
        if (!isNaN(v) && v >= 0) parsedPriceMax = v;
      } else if ($.isPriceRangeKey(key)) {
        const parts = value.split("-");
        if (parts.length === 2) {
          const min = formatPrice(parseFloat(parts[0]));
          const max = formatPrice(parseFloat(parts[1]));
          if (!isNaN(min) && min >= 0) parsedPriceMin = min;
          if (!isNaN(max) && max >= 0) parsedPriceMax = max;
        }
      } else if ($.equals(key, "page" /* PAGE */)) params.page = parseInt(value, 10) || 1;
      else if ($.equals(key, "limit" /* LIMIT */)) params.limit = parseInt(value, 10) || Config.PAGE_SIZE;
      else if ($.equals(key, "sort" /* SORT */)) {
        const sortValue = value.toLowerCase().trim();
        if ($.isBestSelling(sortValue)) {
          params.sort = { field: "best-selling" /* BEST_SELLING */, order: "asc" /* ASC */ };
        } else if (sortValue.includes("-")) {
          const [field, direction] = sortValue.split("-");
          const order = $.equalsAny(direction, "ascending" /* ASCENDING */) ? "asc" /* ASC */ : $.equalsAny(direction, "descending" /* DESCENDING */) ? "desc" /* DESC */ : "desc" /* DESC */;
          params.sort = { field, order };
        } else {
          const [field, order] = value.split(":");
          params.sort = { field, order: $.equalsAny(order, "asc" /* ASC */) ? "asc" /* ASC */ : "desc" /* DESC */ };
        }
      } else {
        params[key] = $.split(value);
        Log.debug("Handle filter parsed directly", { handle: key, value });
      }
    });
    if (parsedPriceMin !== void 0 || parsedPriceMax !== void 0) {
      params.priceRange = {
        min: parsedPriceMin,
        max: parsedPriceMax
      };
    }
    return params;
  },
  update(filters, pagination, sort) {
    const url = new URL(window.location.href);
    url.search = "";
    Log.debug("Updating URL", { filters, pagination });
    if (filters && !$.empty(filters)) {
      Object.keys(filters).forEach((key) => {
        var _a;
        const value = filters[key];
        if ($.empty(value)) return;
        if (Array.isArray(value) && value.length > 0) {
          url.searchParams.set(key, value.join(","));
          Log.debug("URL param set", { key, value: value.join(",") });
        } else if ($.isPriceRangeKey(key) && value && typeof value === "object" && !Array.isArray(value)) {
          const priceRange = value;
          const min = typeof priceRange.min === "number" && !isNaN(priceRange.min) ? formatPrice(priceRange.min) : void 0;
          const max = typeof priceRange.max === "number" && !isNaN(priceRange.max) ? formatPrice(priceRange.max) : void 0;
          if (FilterState.priceRangeHandle) {
            const handleValue = `${min !== void 0 ? min : ""}-${max !== void 0 ? max : ""}`;
            url.searchParams.set(FilterState.priceRangeHandle, handleValue);
            Log.debug("Price range URL handle param set", { handle: FilterState.priceRangeHandle, value: handleValue });
          } else {
            if (min !== void 0) url.searchParams.set("priceMin", String(min));
            if (max !== void 0) url.searchParams.set("priceMax", String(max));
            Log.debug("Price range URL params set", { priceMin: min, priceMax: max });
          }
        } else if ($.equals(key, "search" /* SEARCH */) && typeof value === "string" && value.trim()) {
          const isSearchTemplate = ((_a = window.AFS_Config) == null ? void 0 : _a.isSearchTemplate) || false;
          const paramKey = isSearchTemplate ? "q" : "search";
          url.searchParams.set(paramKey, value.trim());
          Log.debug("Search URL param set", { key: paramKey, value: value.trim(), isSearchTemplate });
        }
      });
    }
    if (pagination && pagination.page > 1) {
      url.searchParams.set("page", String(pagination.page));
      Log.debug("Page URL param set", { page: pagination.page });
    }
    if (sort && sort.field) {
      if (sort.field === "best-selling" || sort.field === "bestselling") {
        url.searchParams.set("sort", "best-selling");
      } else {
        const direction = $.equals(sort.order, "asc" /* ASC */) ? "ascending" /* ASCENDING */ : "descending" /* DESCENDING */;
        url.searchParams.set("sort", `${sort.field}-${direction}`);
      }
      Log.debug("Sort URL param set", { field: sort.field, order: sort.order });
    }
    const newUrl = url.toString();
    Log.info("URL updated", { newUrl, oldUrl: window.location.href });
    history.pushState({ filters, pagination, sort }, "", url);
  }
};
var API = {
  baseURL: "https://fstaging.digitalcoo.com/storefront",
  // Default, should be set via config
  __v: "v2.0",
  __id: "01-13-2026",
  cache: /* @__PURE__ */ new Map(),
  timestamps: /* @__PURE__ */ new Map(),
  pending: /* @__PURE__ */ new Map(),
  key(filters, pagination, sort) {
    const page = pagination && typeof pagination === "object" && typeof pagination.page === "number" ? pagination.page : 1;
    const limit = pagination && typeof pagination === "object" && typeof pagination.limit === "number" ? pagination.limit : Config.PAGE_SIZE || 24;
    const sortField = sort && typeof sort === "object" && sort.field ? sort.field : "best-selling";
    const sortOrder = sort && typeof sort === "object" && sort.order ? sort.order : "asc";
    return `${page}-${limit}-${sortField}-${sortOrder}-${JSON.stringify(filters)}`;
  },
  get(key) {
    const ts = this.timestamps.get(key);
    if (!ts || Date.now() - ts > Config.CACHE_TTL) {
      this.cache.delete(key);
      this.timestamps.delete(key);
      return null;
    }
    return this.cache.get(key) || null;
  },
  set(key, value) {
    this.cache.set(key, value);
    this.timestamps.set(key, Date.now());
  },
  async fetch(url, timeout = Config.TIMEOUT) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    try {
      Log.debug("Fetching", { url });
      const res = await fetch(url, { signal: controller.signal });
      clearTimeout(timeoutId);
      if (!res.ok) {
        const errorText = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status}: ${res.statusText}${errorText ? " - " + errorText : ""}`);
      }
      const data = await res.json();
      Log.debug("Fetch success", { url, hasData: !!data });
      return data;
    } catch (e) {
      clearTimeout(timeoutId);
      if (e instanceof Error && e.name === "AbortError") throw new Error("Request timeout");
      Log.error("Fetch failed", { url, error: e instanceof Error ? e.message : String(e) });
      throw e;
    }
  },
  async products(filters, pagination, sort) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.baseURL) throw new Error('API baseURL not set. Call AFS.init({ apiBaseUrl: "..." })');
    if (!FilterState.shop) throw new Error("Shop not set");
    const safePagination = pagination && typeof pagination === "object" ? pagination : {
      page: ((_a = FilterState.pagination) == null ? void 0 : _a.page) || 1,
      limit: ((_b = FilterState.pagination) == null ? void 0 : _b.limit) || Config.PAGE_SIZE || 24,
      total: ((_c = FilterState.pagination) == null ? void 0 : _c.total) || 0,
      totalPages: ((_d = FilterState.pagination) == null ? void 0 : _d.totalPages) || 0
    };
    const safeSort = sort && typeof sort === "object" ? sort : {
      field: ((_e = FilterState.sort) == null ? void 0 : _e.field) || "best-selling",
      order: ((_f = FilterState.sort) == null ? void 0 : _f.order) || "asc"
    };
    const key = this.key(filters, safePagination, safeSort);
    const cached = this.get(key);
    if (cached) {
      Log.debug("Cache hit", { key });
      return cached;
    }
    if (this.pending.has(key)) {
      Log.debug("Request deduplication", { key });
      return this.pending.get(key);
    }
    const params = new URLSearchParams();
    params.set("shop", FilterState.shop);
    if ((_g = FilterState.selectedCollection) == null ? void 0 : _g.id) {
      params.set("cpid", FilterState.selectedCollection.id);
      Log.debug("cpid sent to products API", { cpid: FilterState.selectedCollection.id, filters });
    } else {
      Log.warn("cpid not available in selectedCollection", { selectedCollection: FilterState.selectedCollection });
    }
    Object.keys(filters).forEach((k) => {
      const v = filters[k];
      if ($.empty(v)) return;
      if ($.isPriceRangeKey(k) && v && typeof v === "object" && !Array.isArray(v)) {
        const priceRange = v;
        const min = typeof priceRange.min === "number" && !isNaN(priceRange.min) ? formatPrice(priceRange.min) : void 0;
        const max = typeof priceRange.max === "number" && !isNaN(priceRange.max) ? formatPrice(priceRange.max) : void 0;
        if (FilterState.priceRangeHandle) {
          params.set(FilterState.priceRangeHandle, `${min !== void 0 ? min : ""}-${max !== void 0 ? max : ""}`);
        } else {
          if (min !== void 0) params.set("priceMin", String(min));
          if (max !== void 0) params.set("priceMax", String(max));
        }
      } else if (k === "search" && typeof v === "string" && v.trim()) {
        params.set(k, v.trim());
      } else {
        if (Array.isArray(v) && v.length > 0) {
          params.set(k, v.join(","));
          Log.debug("Filter sent as direct handle param", { handle: k, value: v.join(",") });
        } else if (typeof v === "string") {
          params.set(k, v);
          Log.debug("Filter sent as direct handle param", { handle: k, value: v });
        }
      }
    });
    params.set("page", String(safePagination.page));
    params.set("limit", String(safePagination.limit));
    if (safeSort.field) {
      if ($.isBestSelling(safeSort.field)) {
        params.set("sort", "best-selling" /* BEST_SELLING */);
      } else {
        const direction = $.equals(safeSort.order, "asc" /* ASC */) ? "ascending" /* ASCENDING */ : "descending" /* DESCENDING */;
        params.set("sort", `${safeSort.field}-${direction}`);
      }
    }
    const url = `${this.baseURL}/products?${params}`;
    Log.info("Fetching products", { url, shop: FilterState.shop, page: safePagination.page });
    DOM.showProductsSkeleton();
    const promise = this.fetch(url).then((res) => {
      var _a2, _b2;
      if (!res.success || !res.data) {
        Log.error("Invalid products response", { response: res });
        throw new Error(`Invalid products response: ${res.message || Lang.messages.unknownError}`);
      }
      const data = res.data;
      Log.info("Products response", {
        productsCount: ((_a2 = data.products) == null ? void 0 : _a2.length) || 0,
        total: ((_b2 = data.pagination) == null ? void 0 : _b2.total) || 0,
        hasFilters: !!data.filters
      });
      this.set(key, data);
      this.pending.delete(key);
      return data;
    }).catch((e) => {
      this.pending.delete(key);
      Log.error("Products fetch failed", { error: e instanceof Error ? e.message : String(e), url });
      throw e;
    });
    DOM.showProductsSkeleton();
    this.pending.set(key, promise);
    return promise;
  },
  async filters(filters) {
    var _a;
    if (!this.baseURL) throw new Error('API baseURL not set. Call AFS.init({ apiBaseUrl: "..." })');
    if (!FilterState.shop) throw new Error("Shop not set");
    const params = new URLSearchParams();
    params.set("shop", FilterState.shop);
    if ((_a = FilterState.selectedCollection) == null ? void 0 : _a.id) {
      params.set("cpid", FilterState.selectedCollection.id);
      Log.debug("cpid sent to filters API", { cpid: FilterState.selectedCollection.id, filters });
    } else {
      Log.warn("cpid not available in selectedCollection", { selectedCollection: FilterState.selectedCollection });
    }
    const filtersForAggregation = { ...filters };
    Object.keys(filtersForAggregation).forEach((k) => {
      const v = filtersForAggregation[k];
      if ($.empty(v)) return;
      if (Array.isArray(v)) {
        params.set(k, v.join(","));
      } else if (k === "search" && typeof v === "string" && v.trim()) {
        params.set("search", v.trim());
      } else if (k === "priceRange" && v && typeof v === "object" && !Array.isArray(v)) {
        const priceRange = v;
        const min = typeof priceRange.min === "number" && !isNaN(priceRange.min) ? priceRange.min : void 0;
        const max = typeof priceRange.max === "number" && !isNaN(priceRange.max) ? priceRange.max : void 0;
        if (FilterState.priceRangeHandle) {
          params.set(FilterState.priceRangeHandle, `${min !== void 0 ? min : ""}-${max !== void 0 ? max : ""}`);
        } else {
          if (min !== void 0) params.set("priceMin", String(min));
          if (max !== void 0) params.set("priceMax", String(max));
        }
      }
    });
    const allParams = {};
    params.forEach((value, key) => {
      allParams[key] = value;
    });
    Log.debug("All params for filters endpoint", {
      params: allParams
    });
    const url = `${this.baseURL}/filters?${params}`;
    Log.info("Fetching filters", { url, shop: FilterState.shop });
    DOM.showLoading();
    const res = await this.fetch(url);
    if (!res.success || !res.data) {
      Log.error("Invalid filters response", { response: res });
      throw new Error(`Invalid filters response: ${res.message || Lang.messages.unknownError}`);
    }
    const data = res.data;
    if (!data || typeof data !== "object") {
      throw new Error("Invalid filters response: data is not an object");
    }
    if (data.filters !== void 0 && !Array.isArray(data.filters)) {
      Log.warn("Filters response contains non-array filters", { filters: data.filters });
      data.filters = [];
    }
    Log.info("Filters response:", { filters: data.filters });
    return data;
  },
  setBaseURL(url) {
    this.baseURL = url;
  },
  buildFiltersFromUrl(urlParams) {
    const searchQuery = urlParams.search || urlParams.q || "";
    FilterState.filters = {
      vendor: urlParams.vendor || [],
      productType: urlParams.productType || [],
      tags: urlParams.tags || [],
      collections: urlParams.collections || [],
      search: searchQuery,
      priceRange: urlParams.priceRange || null
    };
    Object.keys(urlParams).forEach((key) => {
      if (!["vendor", "productType", "tags", "collections", "search", "priceRange", "page", "limit", "sort", "cpid"].includes(key)) {
        const paramValue = urlParams[key];
        if (Array.isArray(paramValue)) {
          FilterState.filters[key] = paramValue;
        } else if (typeof paramValue === "string") {
          FilterState.filters[key] = [paramValue];
        }
      }
    });
  },
  setPaginationFromUrl(urlParams) {
    if (urlParams.page) {
      FilterState.pagination.page = urlParams.page;
    } else {
      if (FilterState.fallbackPagination && FilterState.fallbackPagination.currentPage) {
        FilterState.pagination.page = FilterState.fallbackPagination.currentPage;
      }
    }
  },
  setSortFromUrl(urlParams) {
    if (urlParams.sort) {
      const sortValue = typeof urlParams.sort === "object" ? urlParams.sort.field : urlParams.sort;
      if (typeof sortValue === "string") {
        const normalized = sortValue.toLowerCase().trim();
        if (normalized === "best-selling" || normalized === "bestselling") {
          FilterState.sort = { field: "best-selling", order: "asc" };
        } else if (normalized.includes("-")) {
          const [field, direction] = normalized.split("-");
          const order = $.equalsAny(direction, "ascending" /* ASCENDING */) ? "asc" /* ASC */ : $.equalsAny(direction, "descending" /* DESCENDING */) ? "desc" /* DESC */ : "desc" /* DESC */;
          FilterState.sort = { field, order };
        } else {
          const [field, order] = sortValue.split(":");
          FilterState.sort = { field, order: order || "desc" };
        }
      } else if (typeof urlParams.sort === "object" && urlParams.sort.field) {
        FilterState.sort = { field: urlParams.sort.field, order: urlParams.sort.order || "desc" };
      }
    } else {
      FilterState.sort = { field: "best-selling", order: "asc" };
    }
  }
};
var DOM = {
  container: null,
  filtersContainer: null,
  productsContainer: null,
  productsInfo: null,
  productsGrid: null,
  loading: null,
  sortContainer: null,
  sortSelect: null,
  mobileFilterButton: null,
  mobileFilterClose: null,
  mobileFilterBackdrop: null,
  mobileResultsButton: null,
  init(containerSel, filtersSel, productsSel) {
    if (!containerSel || typeof containerSel !== "string" || containerSel.trim() === "") {
      throw new Error("Container selector cannot be empty. Provide a valid selector or ensure [data-afs-container] exists in the DOM.");
    }
    this.container = document.querySelector(containerSel) || document.querySelector("[data-afs-container]");
    if (!this.container) {
      throw new Error(`Container not found. Selector: "${containerSel}". Please ensure the container element exists in the DOM.`);
    }
    this.container.setAttribute("data-afs-container", "true");
    this.initSearchBar();
    const main = this.container.querySelector(".afs-main-content") || $.el("div", "afs-main-content");
    if (!main.parentNode) this.container.appendChild(main);
    this.filtersContainer = filtersSel && filtersSel.trim() !== "" ? document.querySelector(filtersSel) || null : null;
    if (!this.filtersContainer) {
      this.filtersContainer = $.el("div", "afs-filters-container");
    }
    const searchBar = this.container.querySelector("[data-afs-search-bar]");
    if (searchBar) {
      if (searchBar.parentNode) {
        searchBar.parentNode.removeChild(searchBar);
      }
      if (this.container && !searchBar.parentNode) {
        this.container.insertBefore(searchBar, this.container.firstChild);
      }
    }
    if (!this.filtersContainer.parentNode && main) main.appendChild(this.filtersContainer);
    if (window.innerWidth <= 767) {
      this.filtersContainer.classList.remove("afs-filters-container--open");
    }
    this.mobileFilterBackdrop = this.container.querySelector(".afs-mobile-filter-backdrop");
    if (!this.mobileFilterBackdrop) {
      this.mobileFilterBackdrop = $.el("div", "afs-mobile-filter-backdrop", {
        "data-afs-action": "close-filters"
      });
      this.mobileFilterBackdrop.style.display = "none";
      if (main.parentNode) {
        main.parentNode.insertBefore(this.mobileFilterBackdrop, main);
      } else {
        this.container.appendChild(this.mobileFilterBackdrop);
      }
    }
    this.productsContainer = productsSel && productsSel.trim() !== "" ? document.querySelector(productsSel) || null : null;
    if (!this.productsContainer) {
      this.productsContainer = $.el("div", "afs-products-container");
    }
    if (!this.productsContainer.parentNode && main) main.appendChild(this.productsContainer);
    this.productsInfo = $.el("div", "afs-products-info");
    if (this.productsContainer) {
      this.productsContainer.insertBefore(this.productsInfo, this.productsContainer.firstChild);
    }
    this.mobileFilterButton = $.el("button", "afs-mobile-filter-button", {
      type: "button",
      "data-afs-action": "toggle-filters",
      "aria-label": Lang.buttons.toggleFilters
    });
    this.mobileFilterButton.innerHTML = `<span class="afs-mobile-filter-button__icon">\u2630</span> <span class="afs-mobile-filter-button__text">${Lang.buttons.filters}</span>`;
    if (this.productsInfo) {
      this.productsInfo.insertBefore(this.mobileFilterButton, this.productsInfo.firstChild);
    }
    this.sortContainer = $.el("div", "afs-sort-container");
    const sortLabel = $.el("label", "afs-sort-label", { "for": "afs-sort-label" });
    sortLabel.textContent = Lang.labels.sortBy;
    this.sortSelect = $.el("select", "afs-sort-select", { "data-afs-sort": "true" });
    this.sortSelect.innerHTML = `
        <option value="${"best-selling" /* BEST_SELLING */}">${Lang.sortOptions.bestSelling}</option>
        <option value="title-${"ascending" /* ASCENDING */}">${Lang.sortOptions.titleAsc}</option>
        <option value="title-${"descending" /* DESCENDING */}">${Lang.sortOptions.titleDesc}</option>
        <option value="price-${"ascending" /* ASCENDING */}">${Lang.sortOptions.priceAsc}</option>
        <option value="price-${"descending" /* DESCENDING */}">${Lang.sortOptions.priceDesc}</option>
        <option value="created-${"ascending" /* ASCENDING */}">${Lang.sortOptions.createdAsc}</option>
        <option value="created-${"descending" /* DESCENDING */}">${Lang.sortOptions.createdDesc}</option>
      `;
    this.sortContainer.appendChild(sortLabel);
    this.sortContainer.appendChild(this.sortSelect);
    if (this.productsInfo) {
      this.productsInfo.appendChild(this.sortContainer);
    }
    this.productsGrid = $.el("div", "afs-products-grid");
    if (this.productsContainer) {
      this.productsContainer.appendChild(this.productsGrid);
    }
  },
  initSearchBar() {
    var _a;
    if (!this.container) return;
    const searchBar = this.container.querySelector("[data-afs-search-bar]");
    if (!searchBar) return;
    const searchInput = searchBar.querySelector("[data-afs-search-input]");
    const searchForm = searchBar.querySelector("[data-afs-search-form]");
    if (!searchInput || !searchForm) return;
    searchBar.style.display = "";
    const urlParams = UrlManager.parse();
    const initialQuery = urlParams.q || urlParams.search || "";
    if (initialQuery) {
      searchInput.value = String(initialQuery);
    }
    searchForm.addEventListener("submit", (e) => {
      e.preventDefault();
      const query = searchInput.value.trim();
      if (query) {
        FilterState.filters.search = query;
        FilterState.pagination.page = 1;
        UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
        DOM.scrollToProducts();
        DOM.showProductsSkeleton();
        Filters.apply();
      }
    });
    const debounceDelay = ((_a = window.AFS_Config) == null ? void 0 : _a.isSearchTemplate) ? 400 : Config.DEBOUNCE;
    let debounceTimer = null;
    searchInput.addEventListener("input", () => {
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        const query = searchInput.value.trim();
        FilterState.filters.search = query;
        FilterState.pagination.page = 1;
        UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
        DOM.scrollToProducts();
        DOM.showProductsSkeleton();
        Filters.apply();
      }, debounceDelay);
    });
    const syncSearchInput = () => {
      const urlParams2 = UrlManager.parse();
      const currentQuery = String(urlParams2.q || urlParams2.search || "");
      if (searchInput.value !== currentQuery) {
        searchInput.value = currentQuery;
      }
    };
    window.addEventListener("popstate", syncSearchInput);
    searchInput._syncSearchInput = syncSearchInput;
    Log.debug("Search bar initialized", { hasInput: !!searchInput, hasForm: !!searchForm });
  },
  attachEvents() {
    if (!DOM.container) return;
    DOM.container.addEventListener("click", (e) => {
      var _a, _b, _c, _d, _e, _f, _g;
      const target = e.target;
      const action = (_a = target.closest("[data-afs-action]")) == null ? void 0 : _a.dataset.afsAction;
      const item = target.closest(".afs-filter-item");
      const checkbox = target instanceof HTMLInputElement && (target.type === "checkbox" || target.type === "radio") ? target : item == null ? void 0 : item.querySelector(".afs-filter-item__checkbox");
      const pagination = target.closest(".afs-pagination__button");
      if (action === "clear-all") {
        FilterState.filters = { vendor: [], productType: [], tags: [], collections: [], search: "", priceRange: null };
        if ((_b = FilterState.selectedCollection) == null ? void 0 : _b.id) {
          Log.debug("Clear All: keeping server-managed cpid (not exposed to UI)");
        }
        FilterState.pagination.page = 1;
        UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
        DOM.scrollToProducts();
        DOM.showProductsSkeleton();
        Filters.apply();
      } else if (action === "toggle-filters" || action === "close-filters") {
        if (action === "close-filters") {
          DOM.toggleMobileFilters();
        } else {
          DOM.toggleMobileFilters();
        }
      } else if (target.closest(".afs-applied-filter-chip__remove")) {
        const chip = target.closest(".afs-applied-filter-chip");
        const removeBtn = chip == null ? void 0 : chip.querySelector(".afs-applied-filter-chip__remove");
        const key = removeBtn == null ? void 0 : removeBtn.getAttribute("data-afs-filter-key");
        const value = removeBtn == null ? void 0 : removeBtn.getAttribute("data-afs-filter-value");
        if (!key) return;
        if ($.equals(key, "cpid" /* CPID */)) {
          if ((_c = FilterState.selectedCollection) == null ? void 0 : _c.id) {
            Log.debug("cpid removed, cleared selectedCollection");
          }
          UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
          DOM.scrollToProducts();
          DOM.showProductsSkeleton();
          Filters.apply();
          return;
        }
        if ($.equals(key, "search" /* SEARCH */)) {
          FilterState.filters.search = "";
          FilterState.pagination.page = 1;
          UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
          DOM.scrollToProducts();
          DOM.showProductsSkeleton();
          Filters.apply();
          return;
        }
        if ($.isPriceRangeKey(key)) {
          FilterState.filters.priceRange = null;
          FilterState.pagination.page = 1;
          UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
          DOM.scrollToProducts();
          DOM.showProductsSkeleton();
          Filters.apply();
          return;
        }
        if (value) {
          Filters.toggle(key, value);
        }
      } else if (checkbox && item) {
        e.preventDefault();
        e.stopPropagation();
        const handle = item.getAttribute("data-afs-filter-handle") || ((_d = item.parentElement) == null ? void 0 : _d.getAttribute("data-afs-filter-handle"));
        const value = item.getAttribute("data-afs-filter-value");
        const allowMultiselect = item.getAttribute("data-afs-filter-multiselect") || ((_e = item.parentElement) == null ? void 0 : _e.getAttribute("data-afs-filter-multiselect"));
        if (!handle || !value) {
          Log.warn("Invalid filter item clicked", { handle, value });
          return;
        }
        Log.debug("Filter toggle", { handle, value, currentChecked: checkbox.checked });
        if (allowMultiselect === "0" || allowMultiselect === "false") {
          FilterState.filters[handle] = [];
        }
        Filters.toggle(handle, value);
      } else if (pagination && !pagination.disabled) {
        const page = parseInt(pagination.getAttribute("data-afs-page") || "0", 10);
        if (page && page > 0) {
          if (FilterState.usingFallback) {
            const urlParams = UrlManager.parse();
            const currentPage = urlParams.page || FilterState.pagination.page || 1;
            FilterState.pagination.page = page;
          } else {
            FilterState.pagination.page = page;
          }
          UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
          DOM.scrollToProducts();
          DOM.showProductsSkeleton();
          Filters.applyProductsOnly();
        }
      } else if (target.closest(".afs-filter-group__clear")) {
        e.preventDefault();
        e.stopPropagation();
        const clearBtn = target.closest(".afs-filter-group__clear");
        if (!clearBtn) return;
        const handle = clearBtn.getAttribute("data-afs-filter-handle");
        if (!handle) return;
        const metadata = FilterState.filterMetadata.get(handle);
        const isCollectionFilter = $.isCollectionOptionType(metadata == null ? void 0 : metadata.optionType) || $.isCollectionKey(handle);
        if (FilterState.filters[handle]) {
          delete FilterState.filters[handle];
          Log.debug("Filter cleared", { handle, isCollectionFilter });
          UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
          DOM.scrollToProducts();
          DOM.showProductsSkeleton();
          Filters.apply();
        }
      } else if (target.closest(".afs-filter-group__toggle")) {
        e.preventDefault();
        e.stopPropagation();
        const group = target.closest(".afs-filter-group");
        if (!group) return;
        const collapsed = group.getAttribute("data-afs-collapsed") === "true";
        const collapsedState = !collapsed;
        group.setAttribute("data-afs-collapsed", collapsedState ? "true" : "false");
        const stateKey = group.getAttribute("data-afs-filter-key");
        if (stateKey) {
          try {
            const state = States.get(stateKey) || {};
            state.collapsed = collapsedState;
            state.lastUpdated = Date.now();
            States.set(stateKey, state);
            try {
              const stateKey2 = `afs_filter_state_${group.getAttribute("data-afs-filter-handle")}`;
              sessionStorage.setItem(stateKey2, JSON.stringify({ collapsed: collapsedState }));
            } catch (e2) {
              Log.debug("Could not persist to sessionStorage", { error: e2 instanceof Error ? e2.message : String(e2) });
            }
          } catch (error) {
            Log.error("Failed to persist filter state", {
              stateKey,
              error: error instanceof Error ? error.message : String(error)
            });
          }
        }
        const toggle = group.querySelector(".afs-filter-group__toggle");
        if (toggle) {
          toggle.setAttribute("aria-expanded", collapsedState ? "false" : "true");
        }
        const icon = group.querySelector(".afs-filter-group__icon");
        if (icon) {
          icon.innerHTML = collapsedState ? Icons.rightArrow || "" : Icons.downArrow || "";
        }
        const isTopBarLayout = ((_f = this.container) == null ? void 0 : _f.getAttribute("data-afs-layout")) === "top";
        if (isTopBarLayout && !collapsedState) {
          const allGroups = (_g = this.filtersContainer) == null ? void 0 : _g.querySelectorAll(".afs-filter-group");
          allGroups == null ? void 0 : allGroups.forEach((otherGroup) => {
            if (otherGroup !== group && otherGroup.getAttribute("data-afs-collapsed") === "false") {
              otherGroup.setAttribute("data-afs-collapsed", "true");
              const otherToggle = otherGroup.querySelector(".afs-filter-group__toggle");
              const otherIcon = otherGroup.querySelector(".afs-filter-group__icon");
              if (otherToggle) otherToggle.setAttribute("aria-expanded", "false");
              if (otherIcon) otherIcon.innerHTML = Icons.rightArrow || "";
              const otherStateKey = otherGroup.getAttribute("data-afs-filter-key");
              if (otherStateKey) {
                const otherState = States.get(otherStateKey) || {};
                otherState.collapsed = true;
                States.set(otherStateKey, otherState);
              }
            }
          });
        }
        Log.debug("Filter group toggled", { collapsed: collapsedState, stateKey });
      } else if (target.closest(".afs-product-card__quick-add")) {
        e.preventDefault();
        e.stopPropagation();
        const btn = target.closest(".afs-product-card__quick-add");
        if (!btn || btn.disabled) return;
        const handle = btn.getAttribute("data-product-handle");
        const productId = btn.getAttribute("data-product-id");
        if (handle) {
          QuickAdd.add(handle, productId);
        }
      } else if (target.closest(".afs-product-card__quick-view")) {
        e.preventDefault();
        e.stopPropagation();
        const btn = target.closest(".afs-product-card__quick-view");
        if (!btn) return;
        const handle = btn.getAttribute("data-product-handle");
        if (handle) {
          handleQuickViewClick(handle);
        }
      }
    });
    DOM.container.addEventListener("input", (e) => {
      var _a;
      const target = e.target;
      if (target.classList.contains("afs-filter-group__search-input")) {
        const searchInput = target;
        const term = searchInput.value.toLowerCase();
        const items = (_a = target.closest(".afs-filter-group")) == null ? void 0 : _a.querySelector(".afs-filter-group__items");
        if (items == null ? void 0 : items._items) {
          items.querySelectorAll(".afs-filter-item").forEach((el, i) => {
            var _a2;
            const item = (_a2 = items._items) == null ? void 0 : _a2[i];
            if (item) {
              const searchText = $.str(typeof item === "string" ? item : item.label || item.value || "").toLowerCase();
              el.style.display = !term || searchText.includes(term) ? "" : "none";
            }
          });
        }
      }
    });
    document.addEventListener("click", (e) => {
      var _a, _b;
      const isTopBarLayout = ((_a = this.container) == null ? void 0 : _a.getAttribute("data-afs-layout")) === "top";
      if (!isTopBarLayout) return;
      const target = e.target;
      if (target.closest(".afs-filter-group")) return;
      const openGroups = (_b = this.filtersContainer) == null ? void 0 : _b.querySelectorAll('.afs-filter-group[data-afs-collapsed="false"]');
      openGroups == null ? void 0 : openGroups.forEach((group) => {
        group.setAttribute("data-afs-collapsed", "true");
        const toggle = group.querySelector(".afs-filter-group__toggle");
        const icon = group.querySelector(".afs-filter-group__icon");
        if (toggle) toggle.setAttribute("aria-expanded", "false");
        if (icon) icon.innerHTML = Icons.rightArrow || "";
        const stateKey = group.getAttribute("data-afs-filter-key");
        if (stateKey) {
          const state = States.get(stateKey) || {};
          state.collapsed = true;
          States.set(stateKey, state);
        }
      });
    });
    const handleSortChange = (select) => {
      const sortValue = select.value;
      if (!sortValue) return;
      Log.info("Sort dropdown changed", { sortValue, currentSort: FilterState.sort });
      let newSort;
      if (sortValue === "best-selling" || sortValue === "bestselling") {
        newSort = { field: "best-selling", order: "asc" };
      } else if (sortValue.includes("-")) {
        const [field, direction] = sortValue.split("-");
        const order = direction === "ascending" ? "asc" : direction === "descending" ? "desc" : "desc";
        newSort = { field, order };
      } else {
        const [field, order] = sortValue.split(":");
        newSort = { field, order: order || "desc" };
      }
      FilterState.sort = newSort;
      FilterState.pagination.page = 1;
      UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
      Log.info("Calling applyProductsOnly after sort change", { sort: FilterState.sort });
      DOM.scrollToProducts();
      DOM.showProductsSkeleton();
      Filters.applyProductsOnly();
    };
    let previousSortValue = null;
    DOM.container.addEventListener("focus", (e) => {
      const target = e.target;
      if (target.classList.contains("afs-sort-select")) {
        previousSortValue = target.value;
      }
    }, true);
    DOM.container.addEventListener("change", (e) => {
      const target = e.target;
      if (target.classList.contains("afs-sort-select")) {
        const select = target;
        handleSortChange(select);
        previousSortValue = select.value;
      }
    });
    DOM.container.addEventListener("blur", (e) => {
      const target = e.target;
      if (target.classList.contains("afs-sort-select")) {
        const select = target;
        const currentValue = select.value;
        if (currentValue && currentValue !== previousSortValue) {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              let currentSortValue;
              if ($.isBestSelling(FilterState.sort.field)) {
                currentSortValue = "best-selling" /* BEST_SELLING */;
              } else {
                const direction = $.equals(FilterState.sort.order, "asc" /* ASC */) ? "ascending" /* ASCENDING */ : "descending" /* DESCENDING */;
                currentSortValue = `${FilterState.sort.field}-${direction}`;
              }
              if (currentValue !== currentSortValue) {
                handleSortChange(select);
              }
            });
          });
        }
        previousSortValue = currentValue;
      }
    }, true);
    window.addEventListener("popstate", () => {
      var _a;
      const searchInput = (_a = DOM.container) == null ? void 0 : _a.querySelector("[data-afs-search-input]");
      if (searchInput && searchInput._syncSearchInput) {
        searchInput._syncSearchInput();
      }
      const params = UrlManager.parse();
      const oldFilters = JSON.stringify(FilterState.filters);
      const oldPage = FilterState.pagination.page;
      const oldSort = JSON.stringify(FilterState.sort);
      const searchQuery = String(params.search || params.q || "");
      FilterState.filters = {
        vendor: params.vendor || [],
        productType: params.productType || [],
        tags: params.tags || [],
        collections: params.collections || [],
        search: searchQuery,
        priceRange: params.priceRange || null
      };
      Object.keys(params).forEach((key) => {
        if (!["vendor", "productType", "tags", "collections", "search", "priceRange", "page", "limit", "sort"].includes(key)) {
          const paramValue = params[key];
          if (Array.isArray(paramValue)) {
            FilterState.filters[key] = paramValue;
          } else if (typeof paramValue === "string") {
            FilterState.filters[key] = [paramValue];
          }
        }
      });
      const priceRangeFilterValue = FilterState.priceRangeHandle ? FilterState.filters[FilterState.priceRangeHandle] : null;
      if (FilterState.priceRangeHandle && Array.isArray(priceRangeFilterValue) && priceRangeFilterValue.length > 0) {
        const raw = String(priceRangeFilterValue[0] || "");
        const parts = raw.split("-");
        if (parts.length === 2) {
          const min = parts[0].trim() ? parseInt(parts[0], 10) : void 0;
          const max = parts[1].trim() ? parseInt(parts[1], 10) : void 0;
          const hasMin = typeof min === "number" && !isNaN(min) && min >= 0;
          const hasMax = typeof max === "number" && !isNaN(max) && max >= 0;
          if (hasMin || hasMax) {
            FilterState.filters.priceRange = {
              min: hasMin ? min : void 0,
              max: hasMax ? max : void 0
            };
            delete FilterState.filters[FilterState.priceRangeHandle];
          }
        }
      }
      const newPage = params.page || FilterState.pagination.page;
      if (newPage !== oldPage) {
        FilterState.pagination.page = newPage;
      }
      if (params.sort) {
        const sortValue = typeof params.sort === "object" ? params.sort.field : params.sort;
        if (typeof sortValue === "string") {
          const normalized = sortValue.toLowerCase().trim();
          if (normalized === "best-selling" || normalized === "bestselling") {
            FilterState.sort = { field: "best-selling", order: "asc" };
          } else if (normalized.includes("-")) {
            const [field, direction] = normalized.split("-");
            const order = $.equalsAny(direction, "ascending" /* ASCENDING */) ? "asc" /* ASC */ : $.equalsAny(direction, "descending" /* DESCENDING */) ? "desc" /* DESC */ : "desc" /* DESC */;
            FilterState.sort = { field, order };
          } else {
            const [field, order] = sortValue.split(":");
            FilterState.sort = { field, order: order || "desc" };
          }
        } else if (typeof params.sort === "object" && params.sort.field) {
          FilterState.sort = { field: params.sort.field, order: params.sort.order || "desc" };
        }
      } else {
        FilterState.sort = { field: "best-selling", order: "asc" };
      }
      const newFilters = JSON.stringify(FilterState.filters);
      const newSort = JSON.stringify(FilterState.sort);
      const filtersChanged = oldFilters !== newFilters;
      const onlySortOrPageChanged = !filtersChanged && (newSort !== oldSort || newPage !== oldPage);
      if (onlySortOrPageChanged) {
        Filters.applyProductsOnly();
      } else {
        Filters.apply();
      }
    });
  },
  // Hide filters container (when using fallback mode)
  hideFilters() {
    if (this.filtersContainer) {
      this.filtersContainer.style.display = "none";
      if (this.mobileFilterClose && this.mobileFilterClose.parentNode) {
        this.mobileFilterClose.remove();
        this.mobileFilterClose = null;
      }
      Log.debug("Filters container hidden");
    }
  },
  // Show filters container
  showFilters() {
    if (this.filtersContainer) {
      this.filtersContainer.style.display = "";
      if (window.innerWidth > 767) {
        this.filtersContainer.classList.add("afs-filters-container--open");
      } else {
        this.filtersContainer.classList.remove("afs-filters-container--open");
      }
      Log.debug("Filters container shown");
    }
  },
  // Toggle mobile filters drawer
  toggleMobileFilters() {
    if (!this.filtersContainer) return;
    const isOpen = this.filtersContainer.classList.contains("afs-filters-container--open");
    if (isOpen) {
      this.filtersContainer.classList.remove("afs-filters-container--open");
      document.body.classList.remove("afs-filters-open");
      if (window.innerWidth <= 767 && this.mobileResultsButton && FilterState.pagination.total > 0) {
        this.mobileResultsButton.classList.add("afs-mobile-results-button--visible");
      }
      if (this.mobileFilterBackdrop) {
        this.mobileFilterBackdrop.style.display = "none";
      }
      const scrollY = document.body.style.top;
      document.body.style.overflow = "";
      document.body.style.position = "";
      document.body.style.width = "";
      document.body.style.height = "";
      document.body.style.top = "";
      document.body.style.removeProperty("overflow");
      document.body.style.removeProperty("position");
      document.body.style.removeProperty("width");
      document.body.style.removeProperty("height");
      document.body.style.removeProperty("top");
      if (scrollY) {
        window.scrollTo(0, parseInt(scrollY || "0", 10) * -1);
      }
    } else {
      this.filtersContainer.classList.add("afs-filters-container--open");
      document.body.classList.add("afs-filters-open");
      if (this.mobileResultsButton) {
        this.mobileResultsButton.classList.remove("afs-mobile-results-button--visible");
      }
      if (this.mobileFilterBackdrop) {
        this.mobileFilterBackdrop.style.display = "block";
        this.mobileFilterBackdrop.offsetHeight;
      }
      const scrollY = window.scrollY;
      document.body.style.position = "fixed";
      document.body.style.top = `-${scrollY}px`;
      document.body.style.width = "100%";
      document.body.style.maxWidth = "100vw";
      document.body.style.height = "100%";
      document.body.style.overflow = "hidden";
    }
    Log.debug("Mobile filters drawer toggled", { isOpen: !isOpen });
  },
  // Fastest filter rendering (batched)
  renderFilters(filters) {
    if (!this.filtersContainer || !Array.isArray(filters)) return;
    this.hideFiltersSkeleton();
    States.clear();
    this.filtersContainer.querySelectorAll(".afs-filter-group").forEach((g) => {
      const key = g.getAttribute("data-afs-filter-key");
      if (key) {
        const searchInput = g.querySelector(".afs-filter-group__search-input");
        const collapsed = g.getAttribute("data-afs-collapsed") === "true";
        const search = (searchInput == null ? void 0 : searchInput.value) || "";
        const existingState = States.get(key);
        States.set(key, {
          ...existingState,
          collapsed,
          search,
          // Add timestamp for state freshness tracking
          lastUpdated: Date.now()
        });
      }
    });
    $.clear(this.filtersContainer);
    const validFilters = filters.filter((f) => {
      if (!f) return false;
      if ($.isPriceRangeOptionType(f.optionType)) {
        return f.range && typeof f.range.min === "number" && typeof f.range.max === "number" && f.range.max > f.range.min;
      }
      return f.values && f.values.length > 0;
    });
    Log.debug("Rendering filters", {
      total: filters.length,
      valid: validFilters.length,
      filtersWithSearchable: validFilters.filter((f) => f.searchable).length,
      filtersWithCollapsed: validFilters.filter((f) => f.collapsed).length
    });
    if (validFilters.length === 0) {
      Log.warn("No valid filters to render");
      if (this.mobileFilterClose && this.mobileFilterClose.parentNode) {
        this.mobileFilterClose.remove();
        this.mobileFilterClose = null;
      }
      return;
    }
    if (!this.mobileFilterClose) {
      this.mobileFilterClose = $.el("button", "afs-mobile-filter-close", {
        type: "button",
        "data-afs-action": "close-filters",
        "aria-label": Lang.buttons.closeFilters || "Close filters"
      });
      this.mobileFilterClose.style.display = "none";
    }
    const fragment = document.createDocumentFragment();
    validFilters.forEach((filter) => {
      var _a, _b;
      if ($.isPriceRangeOptionType(filter.optionType)) {
        const group2 = this.createPriceRangeGroup(filter, States);
        if (group2) fragment.appendChild(group2);
        return;
      }
      let handle;
      if (filter.optionType || filter.optionKey) {
        handle = filter.handle;
        if (!handle) {
          Log.error("Option filter missing handle", { filter });
          return;
        }
      } else {
        handle = filter.queryKey || filter.key;
        if (!handle) {
          Log.warn("Standard filter missing queryKey/key", { filter });
          return;
        }
      }
      Log.debug("Filter group handle determined", {
        handle,
        filterHandle: filter.handle,
        queryKey: filter.queryKey,
        key: filter.key,
        label: filter.label,
        type: filter.optionType,
        optionType: filter.optionType,
        optionKey: filter.optionKey,
        isOptionFilter: !!(filter.optionType || filter.optionKey)
      });
      const group = $.el("div", "afs-filter-group", { "data-afs-filter-type": filter.optionType || "" });
      group.setAttribute("data-afs-filter-handle", handle);
      const stateKey = handle;
      group.setAttribute("data-afs-filter-key", stateKey);
      const saved = States.get(stateKey);
      const isTopBarLayout = ((_a = this.container) == null ? void 0 : _a.getAttribute("data-afs-layout")) === "top";
      const defaultCollapsed = isTopBarLayout ? true : filter.collapsed === true || filter.collapsed === "true" || filter.collapsed === 1;
      const collapsed = isTopBarLayout ? true : (saved == null ? void 0 : saved.collapsed) !== void 0 ? saved.collapsed : defaultCollapsed;
      group.setAttribute("data-afs-collapsed", collapsed ? "true" : "false");
      Log.debug("Filter group created", {
        handle,
        label: filter.label,
        collapsed,
        searchable: filter.searchable,
        showCount: filter.showCount,
        valuesCount: ((_b = filter.values) == null ? void 0 : _b.length) || 0
      });
      const header = $.el("div", "afs-filter-group__header");
      const toggle = $.el("button", "afs-filter-group__toggle", {
        type: "button",
        "aria-expanded": !collapsed ? "true" : "false",
        "title": filter.tooltipContent || `Toggle ${filter.label || handle} filter`
      });
      const icon = $.el("span", "afs-filter-group__icon");
      icon.innerHTML = collapsed ? Icons.rightArrow || "" : Icons.downArrow || "";
      toggle.appendChild(icon);
      toggle.appendChild($.txt($.el("label", "afs-filter-group__label", {
        "for": "afs-filter-group__label"
      }), filter.label || filter.optionType || ""));
      header.appendChild(toggle);
      const filterValue = FilterState.filters[handle];
      const hasActiveValues = filterValue && (Array.isArray(filterValue) ? filterValue.length > 0 : typeof filterValue === "object" && !Array.isArray(filterValue) ? Object.keys(filterValue).length > 0 : Boolean(filterValue));
      if (hasActiveValues) {
        const clearBtn = $.el("button", "afs-filter-group__clear", {
          type: "button",
          "aria-label": `${Lang.buttons.clear} ${filter.label || handle} filters`,
          "data-afs-filter-handle": handle
        });
        clearBtn.textContent = Lang.buttons.clear;
        clearBtn.title = `${Lang.buttons.clear} ${filter.label || handle} filters`;
        header.appendChild(clearBtn);
      }
      group.appendChild(header);
      const content = $.el("div", "afs-filter-group__content");
      const isSearchable = filter.searchable === true || typeof filter.searchable === "string" && filter.searchable.toLowerCase() === "true";
      if (isSearchable) {
        const searchContainer = $.el("div", "afs-filter-group__search");
        const search = $.el("input", "afs-filter-group__search-input", {
          "type": "text",
          "placeholder": filter.searchPlaceholder || "Search...",
          "aria-label": `${Lang.labels.search}${filter.label || handle}`,
          "name": `afs-search-${handle}`
        });
        if (saved == null ? void 0 : saved.search) search.value = saved.search;
        searchContainer.appendChild(search);
        content.appendChild(searchContainer);
        Log.debug("Search input added", { handle, label: filter.label, searchable: filter.searchable });
      }
      const items = $.el("div", "afs-filter-group__items", {
        "data-afs-filter-handle": handle,
        "data-afs-filter-multiselect": $.isMultiSelect(filter) ? "1" : "0",
        "data-afs-filter-display-type": $.toLowerCase(filter.displayType || "CHECKBOX")
      });
      items._items = filter.values;
      const itemsFragment = document.createDocumentFragment();
      if (filter.values) {
        filter.values.forEach((item, index) => {
          const itemEl = this.createFilterItem(handle, item, filter, index);
          if (itemEl) itemsFragment.appendChild(itemEl);
        });
      }
      items.appendChild(itemsFragment);
      content.appendChild(items);
      group.appendChild(content);
      fragment.appendChild(group);
    });
    if (fragment.children.length > 0) {
      this.filtersContainer.appendChild(fragment);
      if (this.mobileFilterClose) {
        if (this.mobileFilterClose.parentNode && this.mobileFilterClose.parentNode !== this.filtersContainer) {
          this.mobileFilterClose.parentNode.removeChild(this.mobileFilterClose);
        }
        if (!this.mobileFilterClose.parentNode) {
          this.filtersContainer.insertBefore(this.mobileFilterClose, this.filtersContainer.firstChild);
        }
      }
      this.showFilters();
      Log.debug("Filters rendered", { count: fragment.children.length });
    } else {
      Log.warn("No filter groups created");
      if (this.mobileFilterClose && this.mobileFilterClose.parentNode) {
        this.mobileFilterClose.remove();
        this.mobileFilterClose = null;
      }
      this.hideFilters();
    }
  },
  // Minimal filter item creation
  // Displays label for UI, uses value for filtering
  // handle: the filter handle (e.g., 'ef4gd' for Color, 'vendor' for vendor)
  createFilterItem(handle, item, config, index) {
    var _a;
    const value = $.str(typeof item === "string" ? item : item.value || item.key || item.name || "");
    if (!value || value === "[object Object]") return null;
    let displayLabel = typeof item === "string" ? item : item.label || item.value || value;
    const isCollectionFilter = $.isCollectionOptionType(config == null ? void 0 : config.optionType) || $.isCollectionKey(handle);
    if (isCollectionFilter && FilterState.collections && Array.isArray(FilterState.collections)) {
      if (((_a = FilterState.selectedCollection) == null ? void 0 : _a.id) && String(value) === String(FilterState.selectedCollection.id)) {
        return null;
      }
      const collection = FilterState.collections.find((c) => {
        const cId = String(c.id || c.gid || c.collectionId || "");
        return cId && String(cId) === String(value);
      });
      if (collection) {
        displayLabel = collection.title || collection.label || collection.name || displayLabel;
      } else {
        return null;
      }
    }
    const currentValues = FilterState.filters[handle] || [];
    const isChecked = currentValues.includes(value);
    const inputType = $.inputDisplayType(config);
    const htmlFor = (inputType === "radio" ? handle : handle + "-" + value.replace(/\s+/g, "-").toLowerCase()) + "_" + (index + 1);
    const label = $.el("label", "afs-filter-item", {
      "data-afs-filter-handle": handle,
      "data-afs-filter-value": value,
      "for": htmlFor
    });
    if (isChecked) label.classList.add("afs-filter-item--active");
    const cb = $.el("input", "afs-filter-item__checkbox", { type: inputType });
    cb.checked = isChecked;
    cb.setAttribute("data-afs-filter-value", value);
    cb.setAttribute("name", htmlFor);
    cb.setAttribute("id", htmlFor);
    label.appendChild(cb);
    label.appendChild($.txt($.el("span", "afs-filter-item__label"), displayLabel));
    if ((config == null ? void 0 : config.showCount) && typeof item === "object" && item.count) {
      label.appendChild($.txt($.el("span", "afs-filter-item__count"), `(${item.count})`));
    }
    return label;
  },
  // Create price range filter group with dual-handle slider
  createPriceRangeGroup(filter, savedStates = null) {
    var _a, _b;
    if (!filter.range || typeof filter.range.min !== "number" || typeof filter.range.max !== "number") {
      Log.warn("Invalid price range filter", { filter });
      return null;
    }
    const minRange = formatPrice(filter.range.min);
    const maxRange = formatPrice(filter.range.max);
    const currentRange = FilterState.filters.priceRange || { min: minRange, max: maxRange };
    const currentMin = formatPrice(Math.max(minRange, Math.min(maxRange, typeof currentRange.min === "number" ? currentRange.min : minRange)));
    const currentMax = formatPrice(Math.max(minRange, Math.min(maxRange, typeof currentRange.max === "number" ? currentRange.max : maxRange)));
    const group = $.el("div", "afs-filter-group", {
      "data-afs-filter-type": "priceRange",
      "data-afs-filter-key": filter.key || "priceRange"
    });
    const saved = savedStates == null ? void 0 : savedStates.get(filter.key || "priceRange");
    const isTopBarLayout = ((_a = this.container) == null ? void 0 : _a.getAttribute("data-afs-layout")) === "top";
    const collapsed = isTopBarLayout ? true : (_b = saved == null ? void 0 : saved.collapsed) != null ? _b : filter.collapsed === true;
    group.setAttribute("data-afs-collapsed", collapsed ? "true" : "false");
    const header = $.el("div", "afs-filter-group__header");
    const toggle = $.el("button", "afs-filter-group__toggle", { type: "button", "aria-expanded": !collapsed ? "true" : "false" });
    const icon = $.el("span", "afs-filter-group__icon");
    icon.innerHTML = collapsed ? Icons.rightArrow || "" : Icons.downArrow || "";
    toggle.appendChild(icon);
    toggle.appendChild($.txt($.el("label", "afs-filter-group__label", { "for": "afs-filter-group__label" }), filter.label || "Price"));
    header.appendChild(toggle);
    const isPriceRangeActive = FilterState.filters.priceRange && (typeof FilterState.filters.priceRange.min === "number" && FilterState.filters.priceRange.min !== minRange || typeof FilterState.filters.priceRange.max === "number" && FilterState.filters.priceRange.max !== maxRange);
    if (isPriceRangeActive) {
      const clearBtn = $.el("button", "afs-filter-group__clear", {
        type: "button",
        "aria-label": `${Lang.buttons.clear} ${filter.label} filter`,
        "data-afs-filter-handle": "priceRange"
      });
      clearBtn.textContent = Lang.buttons.clear;
      clearBtn.title = `${Lang.buttons.clear} ${filter.label} filter`;
      header.appendChild(clearBtn);
    }
    group.appendChild(header);
    const content = $.el("div", "afs-filter-group__content");
    const sliderContainer = $.el("div", "afs-price-range-container");
    const track = $.el("div", "afs-price-range-track");
    const activeTrack = $.el("div", "afs-price-range-active");
    track.appendChild(activeTrack);
    const minHandle = $.el("input", "afs-price-range-handle afs-price-range-handle--min", {
      type: "range",
      min: String(minRange),
      max: String(maxRange),
      value: String(currentMin),
      step: "1"
    });
    minHandle.setAttribute("data-afs-range-type", "min");
    const maxHandle = $.el("input", "afs-price-range-handle afs-price-range-handle--max", {
      type: "range",
      min: String(minRange),
      max: String(maxRange),
      value: String(currentMax),
      step: "1"
    });
    maxHandle.setAttribute("data-afs-range-type", "max");
    track.appendChild(minHandle);
    track.appendChild(maxHandle);
    sliderContainer.appendChild(track);
    const valueDisplay = $.el("div", "afs-price-range-values");
    const minDisplay = $.el("span", "afs-price-range-value afs-price-range-value--min");
    const maxDisplay = $.el("span", "afs-price-range-value afs-price-range-value--max");
    const formatPriceDisplay = (val) => `$${parseFloat(String(val)).toFixed(2)}`;
    minDisplay.textContent = formatPriceDisplay(currentMin);
    maxDisplay.textContent = formatPriceDisplay(currentMax);
    valueDisplay.appendChild(minDisplay);
    valueDisplay.appendChild($.txt($.el("span", "afs-price-range-separator"), " - "));
    valueDisplay.appendChild(maxDisplay);
    sliderContainer.appendChild(valueDisplay);
    const updateActiveTrack = () => {
      const min = formatPrice(parseFloat(minHandle.value));
      const max = formatPrice(parseFloat(maxHandle.value));
      const range = maxRange - minRange;
      const leftPercent = (min - minRange) / range * 100;
      const rightPercent = (maxRange - max) / range * 100;
      activeTrack.style.left = `${leftPercent}%`;
      activeTrack.style.right = `${rightPercent}%`;
      minDisplay.textContent = String(min);
      maxDisplay.textContent = String(max);
    };
    const constrainValues = () => {
      const min = formatPrice(parseFloat(minHandle.value));
      const max = formatPrice(parseFloat(maxHandle.value));
      if (min > max) {
        minHandle.value = String(max);
        maxHandle.value = String(min);
      }
      updateActiveTrack();
    };
    minHandle.addEventListener("input", () => {
      constrainValues();
      const minVal = formatPrice(parseFloat(minHandle.value));
      const maxVal = formatPrice(parseFloat(maxHandle.value));
      Filters.updatePriceRange(minVal, maxVal);
    });
    maxHandle.addEventListener("input", () => {
      constrainValues();
      const minVal = formatPrice(parseFloat(minHandle.value));
      const maxVal = formatPrice(parseFloat(maxHandle.value));
      Filters.updatePriceRange(minVal, maxVal);
    });
    updateActiveTrack();
    content.appendChild(sliderContainer);
    group.appendChild(content);
    return group;
  },
  // Fastest product rendering (incremental updates)
  renderProducts(products) {
    if (!this.productsGrid) return;
    const skeletonCards = this.productsGrid.querySelectorAll(".afs-skeleton-card");
    if (skeletonCards.length > 0) {
      skeletonCards.forEach((card) => card.remove());
    }
    const existing = /* @__PURE__ */ new Map();
    this.productsGrid.querySelectorAll("[data-afs-product-id]").forEach((el) => {
      const id = el.getAttribute("data-afs-product-id");
      if (id) existing.set(id, el);
    });
    const productIds = new Set(products.map((p) => $.id(p)).filter((id) => id !== null));
    const fragment = document.createDocumentFragment();
    products.forEach((product) => {
      const id = $.id(product);
      if (!id) return;
      const el = existing.get(id);
      if (el) {
        const title = el.querySelector(".afs-product-card__title");
        if (title && title.textContent !== product.title) title.textContent = product.title || "";
        const price = el.querySelector(".afs-product-card__price");
        if (price) {
          let minPrice = parseFloat(String(product.minPrice || 0)) * 100;
          let maxPrice = parseFloat(String(product.maxPrice || 0)) * 100;
          const formattedMin = $.formatMoney(minPrice, FilterState.moneyFormat || "{{amount}}", FilterState.currency || "");
          const priceText = minPrice === maxPrice ? formattedMin : `${Lang.labels.price}from ${formattedMin}`;
          if (price.textContent !== priceText) price.textContent = priceText;
        }
      } else {
        const productEl = this.createProduct(product);
        if (productEl) fragment.appendChild(productEl);
      }
    });
    existing.forEach((el, id) => {
      if (!productIds.has(id)) el.remove();
    });
    if (fragment.children.length > 0) {
      this.productsGrid.appendChild(fragment);
    }
  },
  // Minimal product creation
  createProduct(p) {
    const card = $.el("div", "afs-product-card", { "data-afs-product-id": $.id(p) || "" });
    if (p.imageUrl || p.featuredImage) {
      const imgContainer = $.el("div", "afs-product-card__image");
      const img = $.el("img", "", {
        alt: p.title || "",
        loading: "lazy",
        decoding: "async",
        fetchpriority: "low"
      });
      const baseImageUrl = p.imageUrl || "";
      let secondImageUrl = null;
      const imagesArray = p.imagesUrls;
      if (imagesArray && Array.isArray(imagesArray) && imagesArray.length > 1) {
        secondImageUrl = imagesArray[1];
        Log.debug("Second image found for hover", {
          secondImageUrl,
          totalImages: imagesArray.length
        });
      }
      if (baseImageUrl) {
        if (p.featuredImage && (p.featuredImage.urlSmall || p.featuredImage.urlMedium || p.featuredImage.urlLarge)) {
          const srcset = [];
          if (p.featuredImage.urlSmall) srcset.push(`${p.featuredImage.urlSmall} 200w`);
          if (p.featuredImage.urlMedium) srcset.push(`${p.featuredImage.urlMedium} 300w`);
          if (p.featuredImage.urlLarge) srcset.push(`${p.featuredImage.urlLarge} 500w`);
          if (srcset.length > 0) {
            img.setAttribute("srcset", srcset.join(", "));
            img.setAttribute("sizes", "(max-width: 768px) 200px, (max-width: 1024px) 300px, 500px");
          }
          img.src = p.featuredImage.url || p.featuredImage.urlFallback || baseImageUrl;
        } else {
          const optimizedUrl = $.optimizeImageUrl(baseImageUrl, { width: 300, format: "webp", quality: 80 });
          const srcset = $.buildImageSrcset(baseImageUrl, [200, 300, 500]);
          if (srcset) {
            img.setAttribute("srcset", srcset);
            img.setAttribute("sizes", "(max-width: 768px) 200px, (max-width: 1024px) 300px, 500px");
          }
          img.src = optimizedUrl || baseImageUrl;
        }
        img.setAttribute("data-original-src", img.src);
        img.onerror = function() {
          var _a;
          const fallbackUrl = ((_a = p.featuredImage) == null ? void 0 : _a.urlFallback) || baseImageUrl;
          if (fallbackUrl && this.src !== fallbackUrl) {
            this.src = fallbackUrl;
            this.setAttribute("data-original-src", fallbackUrl);
          } else if (this.src.includes("_webp.")) {
            const originalUrl = baseImageUrl.replace(/_(?:small|medium|large|grande|compact|master|\d+x\d+)_webp\./i, "_300x300.");
            if (originalUrl !== this.src) {
              this.src = originalUrl;
              this.setAttribute("data-original-src", originalUrl);
            } else {
              this.style.display = "none";
            }
          } else {
            this.style.display = "none";
          }
        };
      }
      imgContainer.appendChild(img);
      if (secondImageUrl) {
        const hoverImageUrl = secondImageUrl;
        const hoverImg = new Image();
        hoverImg.src = hoverImageUrl;
        let originalSrc = img.src || baseImageUrl;
        const updateOriginalSrc = () => {
          const currentSrc = img.src;
          if (currentSrc && currentSrc !== hoverImageUrl) {
            originalSrc = currentSrc;
          }
        };
        if (img.complete) {
          updateOriginalSrc();
        } else {
          img.addEventListener("load", updateOriginalSrc, { once: true });
        }
        imgContainer.addEventListener("mouseenter", () => {
          updateOriginalSrc();
          const swapToHover = () => {
            img.style.opacity = "0";
            setTimeout(() => {
              img.src = hoverImageUrl;
              img.style.opacity = "1";
            }, 150);
          };
          if (hoverImg.complete) {
            swapToHover();
          } else {
            const loadHandler = () => {
              swapToHover();
            };
            if (hoverImg.complete) {
              swapToHover();
            } else {
              hoverImg.addEventListener("load", loadHandler, { once: true });
              hoverImg.addEventListener("error", () => {
                Log.debug("Hover image failed to load", {
                  url: secondImageUrl,
                  hoverImageUrl
                });
              }, { once: true });
            }
          }
        });
        imgContainer.addEventListener("mouseleave", () => {
          img.style.opacity = "0";
          setTimeout(() => {
            img.src = originalSrc;
            img.style.opacity = "1";
          }, 150);
        });
      }
      const isSoldOut = parseInt(String(p.totalInventory || 0), 10) <= 0 || p.variants && !p.variants.some((v) => v.availableForSale);
      if (isSoldOut) {
        const soldOutBadge = $.el("div", "afs-product-card__badge", {
          "class": "afs-product-card__badge--sold-out"
        });
        soldOutBadge.textContent = Lang.buttons.soldOut || "Sold out";
        imgContainer.appendChild(soldOutBadge);
      }
      const quickAddBtn = $.el("button", "afs-product-card__quick-add", {
        "data-product-handle": p.handle || "",
        "data-product-id": $.id(p) || "",
        "aria-label": Lang.buttons.quickAddToCart,
        "type": "button"
      });
      const plusIcon = $.el("span", "afs-product-card__quick-add-icon");
      plusIcon.innerHTML = Icons.plus;
      quickAddBtn.appendChild(plusIcon);
      const quickAddText = $.el("span", "afs-product-card__quick-add-text");
      quickAddText.textContent = Lang.buttons.quickAdd;
      quickAddBtn.appendChild(quickAddText);
      if (parseInt(String(p.totalInventory || 0), 10) <= 0 || p.variants && !p.variants.some((v) => v.availableForSale)) {
        quickAddBtn.disabled = true;
        quickAddBtn.classList.add("afs-product-card__quick-add--disabled");
        quickAddBtn.setAttribute("aria-label", Lang.labels.productUnavailable);
      }
      const quickViewBtn = createQuickViewButton(p);
      if (quickViewBtn) {
        imgContainer.appendChild(quickViewBtn);
      }
      card.appendChild(imgContainer);
    }
    const info = $.el("a", "afs-product-card__info", { "href": `/products/${p.handle}` });
    if (info) {
      info.appendChild($.txt($.el("h3", "afs-product-card__title"), p.title || "Untitled"));
      if (p.vendor) info.appendChild($.txt($.el("div", "afs-product-card__vendor"), p.vendor));
      let minPrice = parseFloat(String(p.minPrice || 0)) * 100;
      let maxPrice = parseFloat(String(p.maxPrice || 0)) * 100;
      const formattedMin = $.formatMoney(minPrice, FilterState.moneyFormat || "{{amount}}", FilterState.currency || "");
      const priceText = minPrice === maxPrice ? formattedMin : `from ${formattedMin}`;
      info.appendChild($.txt($.el("div", "afs-product-card__price"), priceText));
      card.appendChild(info);
    }
    return card;
  },
  // Update filter active state (optimized)
  updateFilterState(handle, value, active) {
    if (!this.filtersContainer) {
      Log.warn("Cannot update filter state: filtersContainer not found");
      return;
    }
    const escapeValue = (val) => String(val).replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&");
    const escapedValue = escapeValue(value);
    const escapedHandle = escapeValue(handle);
    const selector = `.afs-filter-item[data-afs-filter-handle="${escapedHandle}"][data-afs-filter-value="${escapedValue}"]`;
    const item = this.filtersContainer.querySelector(selector);
    if (item) {
      const cb = item.querySelector(".afs-filter-item__checkbox");
      if (cb) {
        cb.checked = active;
        Log.debug("Checkbox state updated", { handle, value, active });
      } else {
        Log.warn("Checkbox not found in filter item", { handle, value });
      }
      item.classList.toggle("afs-filter-item--active", active);
    } else {
      Log.warn("Filter item not found for state update", { handle, value, active, selector });
    }
  },
  // Products info
  renderInfo(pagination, total) {
    if (!this.productsInfo) return;
    const sortContainer = this.sortContainer;
    const existingResults = this.productsInfo.querySelector(".afs-products-info__results");
    if (existingResults) existingResults.remove();
    let resultsEl;
    if (total === 0) {
      resultsEl = $.txt($.el("div", "afs-products-info__results"), Lang.messages.noProductsFound);
    } else if (total === 1) {
      resultsEl = $.txt($.el("div", "afs-products-info__results"), Lang.messages.oneProductFound);
    } else {
      const start = (pagination.page - 1) * pagination.limit + 1;
      const end = Math.min(pagination.page * pagination.limit, total);
      resultsEl = $.txt($.el("div", "afs-products-info__results"), `${Lang.messages.showingProducts} ${start}-${end} of ${total} ${Lang.messages.productsFound}`);
    }
    if (sortContainer && sortContainer.parentNode) {
      this.productsInfo.insertBefore(resultsEl, sortContainer);
    } else {
      this.productsInfo.appendChild(resultsEl);
      if (sortContainer && !sortContainer.parentNode) {
        this.productsInfo.appendChild(sortContainer);
      }
    }
    this.updateMobileResultsButton(total);
  },
  // Create or update mobile sticky results button
  updateMobileResultsButton(total) {
    if (!this.container) return;
    const isMobile = window.innerWidth <= 767;
    if (!isMobile) {
      if (this.mobileResultsButton) {
        this.mobileResultsButton.classList.remove("afs-mobile-results-button--visible");
      }
      return;
    }
    if (!this.mobileResultsButton) {
      this.mobileResultsButton = $.el("div", "afs-mobile-results-button");
      const buttonInner2 = $.el("button", "afs-mobile-results-button-inner", {
        type: "button",
        "aria-label": "View results"
      });
      this.mobileResultsButton.appendChild(buttonInner2);
      if (this.container.parentNode) {
        this.container.parentNode.appendChild(this.mobileResultsButton);
      } else {
        document.body.appendChild(this.mobileResultsButton);
      }
      buttonInner2.addEventListener("click", () => {
        if (this.productsGrid) {
          this.productsGrid.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      });
      let resizeTimeout = null;
      window.addEventListener("resize", () => {
        if (resizeTimeout) {
          clearTimeout(resizeTimeout);
        }
        resizeTimeout = window.setTimeout(() => {
          const isMobileNow = window.innerWidth <= 767;
          if (!isMobileNow && this.mobileResultsButton) {
            this.mobileResultsButton.classList.remove("afs-mobile-results-button--visible");
          } else if (isMobileNow && total > 0 && this.mobileResultsButton && !document.body.classList.contains("afs-filters-open")) {
            this.mobileResultsButton.classList.add("afs-mobile-results-button--visible");
          }
        }, 150);
      });
    }
    const buttonInner = this.mobileResultsButton.querySelector(".afs-mobile-results-button-inner");
    if (buttonInner) {
      if (total === 0) {
        buttonInner.textContent = Lang.messages.noProductsFound || "No products found";
      } else if (total === 1) {
        buttonInner.textContent = `See ${total} result`;
      } else {
        buttonInner.textContent = `See ${total} results`;
      }
    }
    if (total > 0) {
      requestAnimationFrame(() => {
        if (this.mobileResultsButton) {
          const drawerOpen = document.body.classList.contains("afs-filters-open");
          if (drawerOpen) {
            this.mobileResultsButton.classList.remove("afs-mobile-results-button--visible");
          } else {
            this.mobileResultsButton.classList.add("afs-mobile-results-button--visible");
          }
        }
      });
    } else {
      if (this.mobileResultsButton) {
        this.mobileResultsButton.classList.remove("afs-mobile-results-button--visible");
      }
    }
  },
  // Render pagination controls
  renderPagination(pagination) {
    var _a;
    if (!this.productsGrid || !pagination) return;
    const existing = (_a = this.productsGrid.parentNode) == null ? void 0 : _a.querySelector(".afs-pagination");
    if (existing) existing.remove();
    if (pagination.totalPages <= 1) return;
    const paginationEl = $.el("div", "afs-pagination");
    const prevBtn = $.el("button", "afs-pagination__button", {
      type: "button",
      "data-afs-page": String(pagination.page - 1),
      "aria-label": `${Lang.buttons.previous} ${Lang.messages.pageOf.toLowerCase()}`
    });
    prevBtn.textContent = Lang.buttons.previous;
    prevBtn.disabled = pagination.page <= 1;
    paginationEl.appendChild(prevBtn);
    const info = $.el("span", "afs-pagination__info");
    info.textContent = `${Lang.messages.pageOf} ${pagination.page} of ${pagination.totalPages}`;
    paginationEl.appendChild(info);
    const nextBtn = $.el("button", "afs-pagination__button", {
      type: "button",
      "data-afs-page": String(pagination.page + 1),
      "aria-label": `${Lang.buttons.next} ${Lang.messages.pageOf.toLowerCase()}`
    });
    nextBtn.textContent = Lang.buttons.next;
    nextBtn.disabled = pagination.page >= pagination.totalPages;
    paginationEl.appendChild(nextBtn);
    if (this.productsContainer) {
      this.productsContainer.appendChild(paginationEl);
    }
  },
  // Applied filters with clear all
  renderApplied(filters) {
    if (!this.container) return;
    const existing = this.container.querySelector(".afs-applied-filters");
    if (existing) existing.remove();
    const searchBar = this.container.querySelector("[data-afs-search-bar]");
    const activeFilters = [];
    Object.keys(filters).forEach((key) => {
      const value = filters[key];
      if ($.equals(key, "cpid" /* CPID */)) {
      } else if ($.equals(key, "search" /* SEARCH */) && value && typeof value === "string" && value.trim()) {
        activeFilters.push({ handle: key, label: `${Lang.labels.search}${value}`, value });
      } else if ($.isPriceRangeKey(key) && value && typeof value === "object" && !Array.isArray(value)) {
        const priceRange = value;
        const hasMin = typeof priceRange.min === "number" && !isNaN(priceRange.min);
        const hasMax = typeof priceRange.max === "number" && !isNaN(priceRange.max);
        if (hasMin && hasMax) {
          const formattedMin = formatPrice(priceRange.min);
          const formattedMax = formatPrice(priceRange.max);
          activeFilters.push({ handle: key, label: `${Lang.labels.price}$${formattedMin} - $${formattedMax}`, value: "__clear__" /* CLEAR */ });
        } else if (hasMin) {
          const formattedMin = formatPrice(priceRange.min);
          activeFilters.push({ handle: key, label: `${Lang.labels.price}$${formattedMin}+`, value: "__clear__" /* CLEAR */ });
        } else if (hasMax) {
          const formattedMax = formatPrice(priceRange.max);
          activeFilters.push({ handle: key, label: `${Lang.labels.price}Up to $${formattedMax}`, value: "__clear__" /* CLEAR */ });
        }
      } else if (Array.isArray(value) && value.length > 0) {
        value.forEach((v) => {
          const metadata = FilterState.filterMetadata.get(key);
          let label = (metadata == null ? void 0 : metadata.label) || key;
          let displayValue = v;
          const isCollectionFilter = $.isCollectionOptionType(metadata == null ? void 0 : metadata.optionType) || $.isCollectionKey(key);
          if (isCollectionFilter && FilterState.collections && Array.isArray(FilterState.collections)) {
            const collection = FilterState.collections.find((c) => {
              const cId = String(c.id || c.gid || c.collectionId || "");
              return cId && String(cId) === String(v);
            });
            if (collection) {
              displayValue = collection.title || collection.label || collection.name || v;
            }
          }
          activeFilters.push({ handle: key, label: `${label}: ${displayValue}`, value: v });
        });
      }
    });
    if (activeFilters.length === 0) return;
    const appliedContainer = $.el("div", "afs-applied-filters");
    const header = $.el("div", "afs-applied-filters__header");
    header.appendChild($.txt($.el("div", "afs-applied-filters__label"), Lang.labels.appliedFilters));
    appliedContainer.appendChild(header);
    const list = $.el("div", "afs-applied-filters__list");
    activeFilters.forEach((filter) => {
      const chip = $.el("div", "afs-applied-filter-chip");
      chip.appendChild($.txt($.el("span", "afs-applied-filter-chip__label"), filter.label));
      const remove = $.el("button", "afs-applied-filter-chip__remove", {
        "data-afs-filter-key": filter.handle,
        "data-afs-filter-value": filter.value,
        "aria-label": `${Lang.buttons.clear} filter`,
        type: "button"
      });
      remove.innerHTML = Icons.close;
      chip.appendChild(remove);
      list.appendChild(chip);
    });
    const clearAll = $.el("button", "afs-applied-filters__clear-all", {
      "data-afs-action": "clear-all",
      type: "button"
    });
    clearAll.textContent = Lang.buttons.clearAll;
    list.appendChild(clearAll);
    appliedContainer.appendChild(list);
    if (searchBar && searchBar.nextSibling) {
      this.container.insertBefore(appliedContainer, searchBar.nextSibling);
    } else if (searchBar) {
      searchBar.insertAdjacentElement("afterend", appliedContainer);
    } else {
      this.container.insertBefore(appliedContainer, this.container.firstChild);
    }
  },
  scrollToProducts() {
    if (FilterState.scrollToProductsOnFilter === false) {
      return;
    }
    const target = this.productsContainer || this.productsGrid || this.productsInfo;
    if (!target) return;
    const rect = target.getBoundingClientRect();
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
    const topVisible = rect.top >= 0 && rect.top <= viewportHeight;
    if (!topVisible) {
      target.scrollIntoView({ behavior: "smooth", block: "start" });
      Log.debug("Scrolled to products section");
    }
  },
  showLoading() {
    this.showProductsSkeleton();
    this.showFiltersSkeleton();
  },
  hideLoading() {
    var _a;
    try {
      if (Array.isArray(this.loading)) {
        this.loading.forEach((card) => {
          if (card.parentNode) {
            card.remove();
          }
        });
        this.loading = null;
      } else if ((_a = this.loading) == null ? void 0 : _a.parentNode) {
        this.loading.remove();
        this.loading = null;
      }
    } catch (error) {
    }
    this.hideFiltersSkeleton();
  },
  showProductsSkeleton() {
    var _a;
    if (!this.productsGrid) return;
    $.clear(this.productsGrid);
    const pageSize = ((_a = FilterState.pagination) == null ? void 0 : _a.limit) || Config.PAGE_SIZE || 24;
    const skeletonCount = Math.max(pageSize, 24);
    const skeletonCards = [];
    for (let i = 0; i < skeletonCount; i++) {
      const skeletonCard = $.el("div", "afs-skeleton-card");
      skeletonCard.innerHTML = `
				<div class="afs-skeleton-card__image">&#8203;</div>
				<div class="afs-skeleton-card__info">
					<div class="afs-skeleton-card__title">&#8203;</div>
					<div class="afs-skeleton-card__title" style="width: 60%;">&#8203;</div>
					<div class="afs-skeleton-card__price">&#8203;</div>
				</div>
			`;
      skeletonCards.push(skeletonCard);
    }
    skeletonCards.forEach((card) => this.productsGrid.appendChild(card));
    this.loading = skeletonCards;
  },
  showFiltersSkeleton() {
    if (!this.filtersContainer) return;
    const existingSkeleton = this.filtersContainer.querySelector(".afs-filters-skeleton");
    if (existingSkeleton) {
      existingSkeleton.remove();
    }
    const filtersSkeleton = $.el("div", "afs-filters-skeleton");
    for (let i = 0; i < 4; i++) {
      const skeletonGroup = $.el("div", "afs-skeleton-filter-group");
      skeletonGroup.innerHTML = `
				<div class="afs-skeleton-filter-group__header">
					<div class="afs-skeleton-filter-group__title">&#8203;</div>
				</div>
				<div class="afs-skeleton-filter-group__content">
					<div class="afs-skeleton-filter-item">&#8203;</div>
					<div class="afs-skeleton-filter-item">&#8203;</div>
					<div class="afs-skeleton-filter-item" style="width: 70%;">&#8203;</div>
					<div class="afs-skeleton-filter-item" style="width: 85%;">&#8203;</div>
				</div>
			`;
      filtersSkeleton.appendChild(skeletonGroup);
    }
    this.filtersContainer.appendChild(filtersSkeleton);
  },
  hideFiltersSkeleton() {
    var _a;
    const skeleton = (_a = this.filtersContainer) == null ? void 0 : _a.querySelector(".afs-filters-skeleton");
    if (skeleton) {
      skeleton.remove();
    }
  },
  hideProductsSkeleton() {
    var _a;
    const skeleton = (_a = this.filtersContainer) == null ? void 0 : _a.querySelector(".afs-filters-skeleton");
    if (skeleton) {
      skeleton.remove();
    }
  },
  showError(message) {
    var _a, _b;
    if (!this.productsContainer) {
      this.productsContainer = ((_a = this.container) == null ? void 0 : _a.querySelector(".afs-products-container")) || null;
      if (!this.productsContainer && this.container) {
        const main = this.container.querySelector(".afs-main-content");
        if (main) {
          this.productsContainer = $.el("div", "afs-products-container");
          main.appendChild(this.productsContainer);
        }
      }
    }
    if (!this.productsContainer) {
      Log.error("Cannot show error: productsContainer not found", { message });
      return;
    }
    this.hideLoading();
    const fallbackProductsTotal = (_b = FilterState.fallbackProducts.length) != null ? _b : 0;
    if (FilterState.fallbackProducts && fallbackProductsTotal > 0) {
      Log.warn("API error occurred, using fallback products from Liquid", {
        error: message,
        fallbackCount: fallbackProductsTotal
      });
      FilterState.products = FilterState.fallbackProducts;
      FilterState.pagination = FallbackMode.getPagination();
      ;
      this.renderProducts(FilterState.products);
      if (FilterState.pagination) {
        this.renderInfo(FilterState.pagination, FilterState.pagination.total);
        this.renderPagination(FilterState.pagination);
      }
      return;
    }
    const existingError = this.productsContainer.querySelector(".afs-error-message");
    if (existingError) existingError.remove();
    const error = $.el("div", "afs-error-message");
    error.textContent = message || Lang.messages.failedToLoad;
    if (this.productsGrid) {
      $.clear(this.productsGrid);
      this.productsGrid.appendChild(error);
    } else {
      this.productsContainer.appendChild(error);
    }
    Log.error("Error displayed", { message });
  },
  setSortSelectValue() {
    if (DOM.sortSelect) {
      if ($.isBestSelling(FilterState.sort.field)) {
        DOM.sortSelect.value = "best-selling" /* BEST_SELLING */;
      } else {
        const direction = $.equals(FilterState.sort.order, "asc" /* ASC */) ? "ascending" /* ASCENDING */ : "descending" /* DESCENDING */;
        DOM.sortSelect.value = `${FilterState.sort.field}-${direction}`;
      }
      Log.debug("Sort select value updated programmatically", { value: DOM.sortSelect.value, sort: FilterState.sort });
    }
  }
};
var FallbackMode = {
  // Get pagination info for fallback mode (from URL params and Liquid data)
  getPagination() {
    const urlParams = UrlManager.parse();
    const currentPage = urlParams.page || FilterState.fallbackPagination.currentPage || 1;
    const totalPages = FilterState.fallbackPagination.totalPages || 1;
    const totalProducts = FilterState.fallbackPagination.totalProducts || FilterState.fallbackProducts.length || 0;
    return {
      page: currentPage,
      limit: Config.PAGE_SIZE,
      total: totalProducts,
      totalPages
    };
  },
  // Reload page with updated URL parameters for sort/pagination
  reloadPage(filters, pagination, sort) {
    const url = new URL(window.location.href);
    url.search = "";
    if (sort && sort.field) {
      if (sort.field === "best-selling" || sort.field === "bestselling") {
        url.searchParams.set("sort", "best-selling");
      } else {
        const direction = $.equals(sort.order, "asc" /* ASC */) ? "ascending" /* ASCENDING */ : "descending" /* DESCENDING */;
        url.searchParams.set("sort", `${sort.field}-${direction}`);
      }
    }
    if (pagination && pagination.page) {
      url.searchParams.set("page", String(pagination.page));
    }
    Object.keys(filters || {}).forEach((key) => {
      const value = filters[key];
      if ($.empty(value)) return;
      if (Array.isArray(value) && value.length > 0) {
        url.searchParams.set(key, value.join(","));
      } else if ($.isPriceRangeKey(key) && value && typeof value === "object" && !Array.isArray(value)) {
        const priceRange = value;
        const min = typeof priceRange.min === "number" && !isNaN(priceRange.min) ? formatPrice(priceRange.min) : void 0;
        const max = typeof priceRange.max === "number" && !isNaN(priceRange.max) ? formatPrice(priceRange.max) : void 0;
        if (FilterState.priceRangeHandle) {
          url.searchParams.set(FilterState.priceRangeHandle, `${min !== void 0 ? min : ""}-${max !== void 0 ? max : ""}`);
        } else {
          if (min !== void 0) url.searchParams.set("priceMin", String(min));
          if (max !== void 0) url.searchParams.set("priceMax", String(max));
        }
      } else if ($.equals(key, "search" /* SEARCH */) && typeof value === "string" && value.trim()) {
        url.searchParams.set(key, value.trim());
      }
    });
    Log.info("Reloading page for fallback mode", { url: url.toString(), sort, pagination });
    window.location.href = url.toString();
  }
};
function handleLoadError(e) {
  DOM.hideLoading();
  Log.error("Load failed", {
    error: e instanceof Error ? e.message : String(e),
    stack: e instanceof Error ? e.stack : void 0,
    shop: FilterState.shop,
    apiBaseURL: API.baseURL
  });
  if (FilterState.fallbackProducts && FilterState.fallbackProducts.length > 0) {
    Log.warn("Initial load failed, using fallback products from Liquid", {
      error: e instanceof Error ? e.message : String(e),
      fallbackCount: FilterState.fallbackProducts.length
    });
    FilterState.usingFallback = true;
    FilterState.products = FilterState.fallbackProducts;
    FilterState.pagination = FallbackMode.getPagination();
    FilterState.availableFilters = [];
    DOM.hideFilters();
    if (DOM.sortSelect) {
      if ($.isBestSelling(FilterState.sort.field)) {
        DOM.sortSelect.value = "best-selling" /* BEST_SELLING */;
      } else {
        const direction = $.equals(FilterState.sort.order, "asc" /* ASC */) ? "ascending" /* ASCENDING */ : "descending" /* DESCENDING */;
        DOM.sortSelect.value = `${FilterState.sort.field}-${direction}`;
      }
    }
    DOM.renderProducts(FilterState.products);
    DOM.renderInfo(FilterState.pagination, FilterState.pagination.total);
    DOM.renderPagination(FilterState.pagination);
    DOM.renderApplied(FilterState.filters);
  } else {
    DOM.showError(`${Lang.messages.failedToLoad}: ${e instanceof Error ? e.message : Lang.messages.unknownError}. ${Lang.messages.checkConsole}`);
  }
}
var Products = {
  process: (productsData) => {
    var _a, _b, _c;
    Log.info("Products loaded", { count: ((_a = productsData.products) == null ? void 0 : _a.length) || 0, total: ((_b = productsData.pagination) == null ? void 0 : _b.total) || 0 });
    const hasProducts = productsData.products && Array.isArray(productsData.products) && productsData.products.length > 0;
    if (!hasProducts && FilterState.fallbackProducts && FilterState.fallbackProducts.length > 0) {
      Log.warn("API returned no products, using fallback products from Liquid", {
        apiProductsCount: ((_c = productsData.products) == null ? void 0 : _c.length) || 0,
        fallbackCount: FilterState.fallbackProducts.length
      });
      FilterState.usingFallback = true;
      FilterState.products = FilterState.fallbackProducts;
      FilterState.pagination = FallbackMode.getPagination();
      FilterState.availableFilters = [];
      DOM.hideFilters();
      DOM.hideProductsSkeleton();
    } else {
      FilterState.usingFallback = false;
      FilterState.products = productsData.products || [];
      FilterState.pagination = productsData.pagination || FilterState.pagination;
      DOM.showFilters();
      DOM.renderProducts(FilterState.products);
    }
    Products.updateUI();
  },
  updateUI: () => {
    DOM.renderInfo(FilterState.pagination, FilterState.pagination.total || 0);
    DOM.renderPagination(FilterState.pagination);
    DOM.renderApplied(FilterState.filters);
    DOM.setSortSelectValue();
  }
};
var Filters = {
  process: (filtersData) => {
    try {
      FilterState.availableFilters = filtersData.filters || [];
      try {
        FilterState.filterMetadata = Metadata.buildFilterMetadata(FilterState.availableFilters);
      } catch (error) {
      }
      const priceFilter = FilterState.availableFilters.find((f) => $.isPriceRangeOptionType(f.optionType));
      FilterState.priceRangeHandle = (priceFilter == null ? void 0 : priceFilter.handle) || FilterState.priceRangeHandle || null;
      Log.info("Filters set from URL", { filters: FilterState.filters });
      const priceRangeFilterValue = FilterState.priceRangeHandle ? FilterState.filters[FilterState.priceRangeHandle] : null;
      if (FilterState.priceRangeHandle && Array.isArray(priceRangeFilterValue) && priceRangeFilterValue.length > 0) {
        try {
          const raw = String(priceRangeFilterValue[0] || "");
          const parts = raw.split("-");
          if (parts.length === 2) {
            const min = parts[0].trim() ? parseInt(parts[0], 10) : void 0;
            const max = parts[1].trim() ? parseInt(parts[1], 10) : void 0;
            const hasMin = typeof min === "number" && !isNaN(min) && min >= 0;
            const hasMax = typeof max === "number" && !isNaN(max) && max >= 0;
            if (hasMin || hasMax) {
              FilterState.filters.priceRange = {
                min: hasMin ? min : void 0,
                max: hasMax ? max : void 0
              };
              delete FilterState.filters[FilterState.priceRangeHandle];
            }
          }
        } catch (error) {
        }
      }
      DOM.renderFilters(FilterState.availableFilters);
      Log.info("Filters rendered", { count: FilterState.availableFilters.length });
    } catch (error) {
      Log.error("PROCESS FILTER ERROR", { error: error instanceof Error ? error.message : String(error) });
    } finally {
      Products.updateUI();
      DOM.hideFiltersSkeleton();
    }
  },
  // Toggle standard filter (vendor, productType, tags, collections) or handle-based filter
  toggle(handle, value) {
    var _a;
    const normalized = $.str(value);
    if (!normalized || !handle) {
      Log.warn("Invalid filter toggle", { handle, value });
      return;
    }
    const current = FilterState.filters[handle] || [];
    const isActive = current.includes(normalized);
    const filterValues = isActive ? current.filter((v) => v !== normalized) : [...current, normalized];
    if (filterValues.length === 0) {
      delete FilterState.filters[handle];
    } else {
      FilterState.filters[handle] = filterValues;
    }
    FilterState.pagination.page = 1;
    Log.debug("Filter toggled", { handle, value: normalized, wasActive: isActive, isActive: !isActive, filterValues });
    UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
    DOM.updateFilterState(handle, normalized, !isActive);
    DOM.scrollToProducts();
    DOM.showProductsSkeleton();
    if (window.innerWidth <= 768 && ((_a = DOM.filtersContainer) == null ? void 0 : _a.classList.contains("afs-filters-container--open"))) {
      DOM.filtersContainer.classList.remove("afs-filters-container--open");
      document.body.classList.remove("afs-filters-open");
      if (DOM.mobileFilterBackdrop) {
        DOM.mobileFilterBackdrop.style.display = "none";
      }
      document.body.style.overflow = "";
      document.body.style.position = "";
      document.body.style.width = "";
      document.body.style.height = "";
      document.body.style.top = "";
      document.body.style.removeProperty("overflow");
      document.body.style.removeProperty("position");
      document.body.style.removeProperty("width");
      document.body.style.removeProperty("height");
      document.body.style.removeProperty("top");
      const scrollY = document.body.style.top;
      if (scrollY) {
        window.scrollTo(0, parseInt(scrollY || "0", 10) * -1);
      }
      if (window.innerWidth <= 767 && DOM.mobileResultsButton && FilterState.pagination.total > 0) {
        DOM.mobileResultsButton.classList.add("afs-mobile-results-button--visible");
      }
    }
    this.apply();
  },
  updatePriceRange(min, max) {
    min = formatPrice(min);
    max = formatPrice(max);
    if (typeof min !== "number" || typeof max !== "number" || min < 0 || max < min) {
      Log.warn("Invalid price range", { min, max });
      return;
    }
    const priceFilter = FilterState.availableFilters.find((f) => $.isPriceRangeOptionType(f.optionType) || $.equals(f.optionKey, "priceRange" /* PRICE_RANGE */));
    if (priceFilter && priceFilter.range) {
      const formattedMinRange = formatPrice(priceFilter.range.min);
      const formattedMaxRange = formatPrice(priceFilter.range.max);
      if (min === formattedMinRange && max === formattedMaxRange) {
        FilterState.filters.priceRange = null;
      } else {
        FilterState.filters.priceRange = { min, max };
      }
    } else {
      FilterState.filters.priceRange = { min, max };
    }
    FilterState.pagination.page = 1;
    Log.debug("Price range updated", { min, max, priceRange: FilterState.filters.priceRange });
    UrlManager.update(FilterState.filters, FilterState.pagination, FilterState.sort);
    DOM.scrollToProducts();
    DOM.showProductsSkeleton();
    this.apply();
  },
  // Apply products only (for sort/pagination changes - no filter update needed)
  applyProductsOnly: $.debounce(async () => {
    Log.info("applyProductsOnly called", { filters: FilterState.filters, pagination: FilterState.pagination, sort: FilterState.sort, usingFallback: FilterState.usingFallback });
    if (FilterState.usingFallback) {
      Log.info("In fallback mode, reloading page with new parameters");
      FallbackMode.reloadPage(FilterState.filters, FilterState.pagination, FilterState.sort);
      return;
    }
    DOM.scrollToProducts();
    API.products(FilterState.filters, FilterState.pagination, FilterState.sort).then(Products.process);
  }, Config.DEBOUNCE),
  // Apply filters and products (for filter changes - needs to update both)
  apply: $.debounce(async () => {
    DOM.scrollToProducts();
    API.products(FilterState.filters, FilterState.pagination, FilterState.sort).then(Products.process).catch(handleLoadError).finally(() => {
      DOM.hideProductsSkeleton();
    });
    API.filters(FilterState.filters).then(Filters.process).catch(handleLoadError).finally(() => {
      DOM.hideFiltersSkeleton();
    });
  }, Config.DEBOUNCE)
};
var QuickAdd = {
  async add(handle, productId) {
    try {
      const productUrl = `/products/${handle}.json`;
      const response = await fetch(productUrl);
      if (!response.ok) {
        throw new Error(Lang.messages.failedToLoadProduct);
      }
      const data = await response.json();
      const product = data.product;
      if (!product || !product.variants || product.variants.length === 0) {
        throw new Error("Product has no variants");
      }
      const variant = product.variants.find((v) => v.available) || product.variants[0];
      await this.addVariant(Number(variant.id), 1);
    } catch (error) {
      Log.error("Quick add failed", { error: error instanceof Error ? error.message : String(error), handle });
      DOM.showError("Failed to add product to cart. Please try again.");
    }
  },
  async addFromForm(form, handle) {
    var _a, _b;
    try {
      const formData = new FormData(form);
      const variantId = formData.get("id");
      const quantity = parseInt(((_a = formData.get("quantity")) == null ? void 0 : _a.toString()) || "1", 10);
      if (!variantId) {
        const options = [];
        for (let i = 1; i <= 3; i++) {
          const option = formData.get(`option${i}`);
          if (option) options.push(option.toString());
        }
        const productUrl = `/products/${handle}.json`;
        const response = await fetch(productUrl);
        const data = await response.json();
        const product = data.product;
        const variant = (_b = product.variants) == null ? void 0 : _b.find((v) => {
          if (!v.options) return false;
          return v.options.length === options.length && v.options.every((opt, idx) => opt === options[idx]);
        });
        if (variant) {
          await this.addVariant(Number(variant.id), quantity);
        } else {
          throw new Error("Variant not found");
        }
      } else {
        await this.addVariant(Number(variantId), quantity);
      }
    } catch (error) {
      Log.error("Add from form failed", { error: error instanceof Error ? error.message : String(error) });
      DOM.showError("Failed to add product to cart. Please try again.");
    }
  },
  async addVariant(variantId, quantity) {
    try {
      const response = await fetch("/cart/add.js", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          id: variantId,
          quantity
        })
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.description || Lang.messages.failedToAddToCart);
      }
      await response.json();
      document.dispatchEvent(new CustomEvent("cart:updated"));
      this.showSuccess();
    } catch (error) {
      Log.error("Add variant failed", { error: error instanceof Error ? error.message : String(error), variantId });
      throw error;
    }
  },
  showSuccess() {
    let toast = document.querySelector(".afs-cart-toast");
    if (!toast) {
      toast = $.el("div", "afs-cart-toast");
      const toastContent = $.el("div", "afs-cart-toast__content");
      const icon = $.el("div", "afs-cart-toast__icon");
      icon.innerHTML = `
				<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
					<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" fill="currentColor"/>
				</svg>
			`;
      const message = $.el("div", "afs-cart-toast__message");
      message.textContent = Lang.messages.addedToCart || "Product added to cart!";
      const closeBtn = $.el("button", "afs-cart-toast__close");
      closeBtn.setAttribute("type", "button");
      closeBtn.setAttribute("aria-label", "Close");
      closeBtn.innerHTML = `
				<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
					<path d="M15 5L5 15M5 5l10 10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
				</svg>
			`;
      toastContent.appendChild(icon);
      toastContent.appendChild(message);
      toast.appendChild(toastContent);
      toast.appendChild(closeBtn);
      document.body.appendChild(toast);
      closeBtn.addEventListener("click", () => {
        toast == null ? void 0 : toast.classList.remove("afs-cart-toast--show");
      });
    }
    toast.classList.add("afs-cart-toast--show");
    const timeoutId = setTimeout(() => {
      toast == null ? void 0 : toast.classList.remove("afs-cart-toast--show");
    }, 4e3);
    toast._timeoutId = timeoutId;
  }
};
var AFS = {
  init(config = {}) {
    var _a, _b, _c, _d;
    try {
      Log.init(config.debug);
      Log.info("Initializing AFS", config);
      if (config.apiBaseUrl) {
        API.setBaseURL(config.apiBaseUrl);
        Log.info("API base URL set", { url: API.baseURL });
      }
      if (!config.shop) {
        throw new Error("Shop parameter is required in config");
      }
      FilterState.shop = config.shop;
      FilterState.collections = config.collections || [];
      FilterState.selectedCollection = {
        id: (_b = (_a = config.selectedCollection) == null ? void 0 : _a.id) != null ? _b : null,
        sortBy: (_d = (_c = config.selectedCollection) == null ? void 0 : _c.sortBy) != null ? _d : null
      };
      FilterState.scrollToProductsOnFilter = config.scrollToProductsOnFilter !== false;
      if (config.isSearchTemplate) {
        window.AFS_Config = { isSearchTemplate: true };
      }
      if (config.initialSearchQuery) {
        const urlParams = UrlManager.parse();
        if (!urlParams.search && !urlParams.q) {
          FilterState.filters.search = config.initialSearchQuery;
        }
      }
      if (config.moneyFormat) {
        FilterState.moneyFormat = config.moneyFormat;
      }
      if (config.moneyWithCurrencyFormat) {
        FilterState.moneyWithCurrencyFormat = config.moneyWithCurrencyFormat;
      }
      if (config.currency) {
        FilterState.currency = config.currency;
      }
      if (config.fallbackProducts && Array.isArray(config.fallbackProducts) && config.fallbackProducts.length > 0) {
        FilterState.fallbackProducts = config.fallbackProducts;
        Log.info("Fallback products loaded from Liquid", { count: FilterState.fallbackProducts.length });
      }
      if (config.fallbackPagination) {
        FilterState.fallbackPagination = config.fallbackPagination;
        Log.info("Fallback pagination loaded from Liquid", {
          currentPage: FilterState.fallbackPagination.currentPage,
          totalPages: FilterState.fallbackPagination.totalPages,
          totalProducts: FilterState.fallbackPagination.totalProducts
        });
      }
      if (config.priceRangeHandle !== void 0) {
        FilterState.priceRangeHandle = config.priceRangeHandle;
      }
      Log.info("Shop set", { shop: FilterState.shop });
      Log.info("Collections set", { collections: FilterState.collections });
      const containerSelector = config.containerSelector || config.container || "[data-afs-container]";
      const filtersSelector = config.filtersSelector || config.filtersContainer;
      const productsSelector = config.productsSelector || config.productsContainer;
      DOM.init(containerSelector, filtersSelector, productsSelector);
      Log.info("DOM initialized");
      DOM.showLoading();
      DOM.attachEvents();
      Log.info("DOM events attached");
      this.load();
    } catch (e) {
      Log.error("Initialization failed", { error: e instanceof Error ? e.message : String(e), stack: e instanceof Error ? e.stack : void 0, config });
      if (DOM.container) {
        DOM.showError(`Initialization failed: ${e instanceof Error ? e.message : String(e)}`);
      }
      throw e;
    }
  },
  async load() {
    DOM.showLoading();
    try {
      const urlParams = UrlManager.parse();
      Log.debug("Parsed URL params on load", { urlParams });
      API.buildFiltersFromUrl(urlParams);
      API.setPaginationFromUrl(urlParams);
      API.setSortFromUrl(urlParams);
      Log.info("Loading products & filters...", { shop: FilterState.shop, filters: FilterState.filters });
      API.filters(FilterState.filters).then(Filters.process).catch(handleLoadError).finally(() => {
        DOM.hideFiltersSkeleton();
      });
      API.products(FilterState.filters, FilterState.pagination, FilterState.sort).then(Products.process).catch(handleLoadError).finally(() => {
        DOM.hideFiltersSkeleton();
      });
    } catch (e) {
      handleLoadError(e);
    }
  },
  Logger: Log
};
var AFSSlider = class {
  constructor(container, options = {}) {
    this._currentIndex = 0;
    this.images = [];
    this.thumbnails = [];
    this.isInitialized = false;
    this.magnifierEnabled = false;
    this.currentZoom = 2;
    // Active zoom level (2x, 3x, 4x, 5x) - initialized from options, can be changed via slider
    this.isTouchDevice = false;
    this.mainContainer = null;
    this.thumbnailContainer = null;
    this.keyboardHandler = null;
    const containerElement = typeof container === "string" ? document.querySelector(container) : container;
    if (!containerElement) {
      Log.error("AFSSlider: Container not found");
      throw new Error("AFSSlider: Container not found");
    }
    this.container = containerElement;
    this.options = {
      thumbnailsPosition: options.thumbnailsPosition || "left",
      enableKeyboard: options.enableKeyboard !== false,
      enableAutoHeight: options.enableAutoHeight !== false,
      maxHeight: options.maxHeight || null,
      animationDuration: options.animationDuration || 300,
      enableMagnifier: options.enableMagnifier !== false,
      magnifierZoom: options.magnifierZoom || 3,
      ...options
    };
    this.magnifierEnabled = this.options.enableMagnifier;
    this.currentZoom = this.options.magnifierZoom || 3;
    this.isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;
    this.init();
  }
  // Public getter for currentIndex to match SliderInstance interface
  get currentIndex() {
    return this._currentIndex;
  }
  init() {
    this.mainContainer = this.container.querySelector(".afs-slider__main");
    if (!this.mainContainer) {
      Log.error("AFSSlider: Main container (.afs-slider__main) not found");
      return;
    }
    this.thumbnailContainer = this.container.querySelector(".afs-slider__thumbnails");
    if (!this.thumbnailContainer) {
      Log.error("AFSSlider: Thumbnail container (.afs-slider__thumbnails) not found");
      return;
    }
    const imageElements = this.mainContainer.querySelectorAll(".afs-slider__image");
    this.images = Array.from(imageElements);
    if (this.images.length === 0) {
      Log.error("AFSSlider: No images found");
      return;
    }
    const thumbnailElements = this.thumbnailContainer.querySelectorAll(".afs-slider__thumbnail");
    this.thumbnails = Array.from(thumbnailElements);
    if (this.thumbnails.length === 0) {
      Log.warn("AFSSlider: No thumbnails found, continuing without thumbnails");
    }
    this.container.setAttribute("data-thumbnails-position", this.options.thumbnailsPosition);
    try {
      this.buildSlider();
    } catch (e) {
      Log.error("AFSSlider: Error building slider structure", { error: e instanceof Error ? e.message : String(e) });
      return;
    }
    try {
      this.setupEvents();
    } catch (e) {
      Log.error("AFSSlider: Error setting up events", { error: e instanceof Error ? e.message : String(e) });
    }
    if (this.magnifierEnabled && !this.isTouchDevice) {
      try {
        setTimeout(() => {
          this.setupPanZoom();
        }, 0);
      } catch (e) {
        Log.error("AFSSlider: Error setting up pan-zoom", { error: e instanceof Error ? e.message : String(e) });
      }
    }
    if (this.isTouchDevice) {
      try {
        this.setupPinchZoom();
      } catch (e) {
        Log.error("AFSSlider: Error setting up pinch-zoom", { error: e instanceof Error ? e.message : String(e) });
      }
    }
    try {
      this.goToSlide(0);
    } catch (e) {
      Log.error("AFSSlider: Error showing first slide", { error: e instanceof Error ? e.message : String(e) });
    }
    this.isInitialized = true;
  }
  buildSlider() {
    if (!this.mainContainer) return;
    if (!this.mainContainer.querySelector(".afs-slider__viewport")) {
      const viewport = document.createElement("div");
      viewport.className = "afs-slider__viewport";
      this.images.forEach((img) => {
        viewport.appendChild(img);
      });
      this.mainContainer.appendChild(viewport);
      if (this.magnifierEnabled && !this.isTouchDevice) {
        this.createZoomControls(viewport);
      }
    }
    if (!this.mainContainer.querySelector(".afs-slider__prev")) {
      const prevBtn2 = document.createElement("button");
      prevBtn2.type = "button";
      prevBtn2.className = "afs-slider__prev";
      prevBtn2.setAttribute("aria-label", "Previous image");
      prevBtn2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>';
      this.mainContainer.appendChild(prevBtn2);
    }
    if (!this.mainContainer.querySelector(".afs-slider__next")) {
      const nextBtn2 = document.createElement("button");
      nextBtn2.type = "button";
      nextBtn2.className = "afs-slider__next";
      nextBtn2.setAttribute("aria-label", "Next image");
      nextBtn2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>';
      this.mainContainer.appendChild(nextBtn2);
    }
    if (this.thumbnails.length === 0 && this.thumbnailContainer) {
      const thumbnailElements = this.thumbnailContainer.querySelectorAll(".afs-slider__thumbnail");
      this.thumbnails = Array.from(thumbnailElements);
    }
    this.thumbnails.forEach((thumb, index) => {
      var _a;
      const newThumb = thumb.cloneNode(true);
      (_a = thumb.parentNode) == null ? void 0 : _a.replaceChild(newThumb, thumb);
      this.thumbnails[index] = newThumb;
      newThumb.addEventListener("click", () => {
        this.goToSlide(index);
      });
    });
    const prevBtn = this.mainContainer.querySelector(".afs-slider__prev");
    const nextBtn = this.mainContainer.querySelector(".afs-slider__next");
    if (prevBtn) {
      prevBtn.addEventListener("click", () => this.prevSlide());
    }
    if (nextBtn) {
      nextBtn.addEventListener("click", () => this.nextSlide());
    }
  }
  setupEvents() {
    if (this.options.enableKeyboard) {
      this.keyboardHandler = (e) => {
        if (!this.isInitialized) return;
        const rect = this.container.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) return;
        switch (e.key) {
          case "ArrowLeft":
            e.preventDefault();
            this.prevSlide();
            break;
          case "ArrowRight":
            e.preventDefault();
            this.nextSlide();
            break;
          case "Escape":
            const activeImage = this.images[this.currentIndex];
            if (activeImage) {
              activeImage.classList.remove("afs-slider__image--zoomed");
              activeImage.classList.add("afs-slider__image--zoom-reset");
              setTimeout(() => {
                activeImage.classList.remove("afs-slider__image--zoom-reset");
              }, 200);
            }
            break;
        }
      };
      document.addEventListener("keydown", this.keyboardHandler);
    }
    this.setupTouchEvents();
    if (this.options.enableAutoHeight) {
      this.adjustHeight();
      window.addEventListener("resize", () => this.adjustHeight());
    }
  }
  setupTouchEvents() {
    if (!this.mainContainer) return;
    let startX = 0;
    let startY = 0;
    let isDragging = false;
    const viewport = this.mainContainer.querySelector(".afs-slider__viewport");
    if (!viewport) return;
    viewport.addEventListener("touchstart", (e) => {
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      isDragging = true;
    }, { passive: true });
    viewport.addEventListener("touchmove", (e) => {
      if (!isDragging) return;
      e.preventDefault();
    }, { passive: false });
    viewport.addEventListener("touchend", (e) => {
      if (!isDragging) return;
      isDragging = false;
      const endX = e.changedTouches[0].clientX;
      const endY = e.changedTouches[0].clientY;
      const diffX = startX - endX;
      const diffY = startY - endY;
      if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
        if (diffX > 0) {
          this.nextSlide();
        } else {
          this.prevSlide();
        }
      }
    }, { passive: true });
  }
  /**
   * Create zoom control slider (2x, 3x, 4x, 5x)
   */
  createZoomControls(viewport) {
    const zoomControls = document.createElement("div");
    zoomControls.className = "afs-slider__zoom-controls";
    const slider = document.createElement("input");
    slider.type = "range";
    slider.className = "afs-slider__zoom-slider";
    slider.setAttribute("min", "2");
    slider.setAttribute("max", "5");
    slider.setAttribute("step", "1");
    slider.setAttribute("value", String(this.currentZoom));
    slider.setAttribute("aria-label", "Zoom level");
    slider.setAttribute("aria-valuemin", "2");
    slider.setAttribute("aria-valuemax", "5");
    slider.addEventListener("input", (e) => {
      e.stopPropagation();
      const level = Number(e.target.value);
      this.setZoomLevel(level);
    });
    slider.addEventListener("mousedown", (e) => {
      e.stopPropagation();
    });
    zoomControls.appendChild(slider);
    viewport.appendChild(zoomControls);
  }
  /**
   * Set zoom level and update UI
   */
  setZoomLevel(level) {
    var _a;
    this.currentZoom = level;
    const viewport = (_a = this.mainContainer) == null ? void 0 : _a.querySelector(".afs-slider__viewport");
    if (viewport) {
      const slider = viewport.querySelector(".afs-slider__zoom-slider");
      if (slider) {
        slider.value = String(level);
        slider.setAttribute("aria-valuenow", String(level));
      }
    }
    const activeImage = this.images[this._currentIndex];
    if (activeImage && activeImage.classList.contains("afs-slider__image--zoomed")) {
      activeImage.style.transform = "scale(1) translate(0, 0)";
      setTimeout(() => {
      }, 50);
    }
  }
  setupPanZoom() {
    if (!this.mainContainer) return;
    const viewport = this.mainContainer.querySelector(".afs-slider__viewport");
    if (!viewport) {
      Log.warn("AFSSlider: Viewport not found for pan-zoom, skipping zoom setup");
      return;
    }
    viewport.classList.add("afs-slider__viewport--zoomable");
    viewport.addEventListener("mousemove", (e) => {
      const activeImage = this.images[this._currentIndex];
      if (!activeImage) return;
      const rect = viewport.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const xPercent = x / rect.width;
      const yPercent = y / rect.height;
      const SCALE = this.currentZoom;
      const translateX = -xPercent * (activeImage.offsetWidth * SCALE - rect.width);
      const translateY = -yPercent * (activeImage.offsetHeight * SCALE - rect.height);
      activeImage.style.transform = `
		scale(${SCALE})
		translate(${translateX / SCALE}px, ${translateY / SCALE}px)
	  `;
      activeImage.classList.add("afs-slider__image--zoomed");
    });
    viewport.addEventListener("mouseenter", () => {
      const activeImage = this.images[this._currentIndex];
      if (activeImage) {
        activeImage.classList.add("afs-slider__image--zoomed");
      }
    });
    viewport.addEventListener("mouseleave", () => {
      const activeImage = this.images[this._currentIndex];
      if (activeImage) {
        activeImage.style.transform = "scale(1) translate(0, 0)";
        activeImage.classList.remove("afs-slider__image--zoomed");
        activeImage.classList.add("afs-slider__image--zoom-reset");
        setTimeout(() => {
          activeImage.classList.remove("afs-slider__image--zoom-reset");
        }, 200);
      }
    });
  }
  /**
   * Setup pinch-to-zoom for touch devices
   */
  setupPinchZoom() {
    if (!this.mainContainer || !this.isTouchDevice) return;
    const viewport = this.mainContainer.querySelector(".afs-slider__viewport");
    if (!viewport) return;
    let initialDistance = 0;
    let currentScale = 1;
    let lastTouchTime = 0;
    let doubleTapTimeout = null;
    viewport.addEventListener("touchstart", (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialDistance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        const activeImage = this.images[this._currentIndex];
        if (activeImage) {
          const transform = activeImage.style.transform || "";
          const scaleMatch = transform.match(/scale\(([\d.]+)\)/);
          currentScale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
        }
      } else if (e.touches.length === 1) {
        const now = Date.now();
        if (now - lastTouchTime < 300) {
          e.preventDefault();
          if (doubleTapTimeout) clearTimeout(doubleTapTimeout);
          const activeImage = this.images[this._currentIndex];
          if (activeImage) {
            const transform = activeImage.style.transform || "";
            const scaleMatch = transform.match(/scale\(([\d.]+)\)/);
            let currentScale2 = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
            if (currentScale2 > 1) {
              activeImage.style.transform = "scale(1) translate(0, 0)";
              currentScale2 = 1;
            } else {
              const rect = viewport.getBoundingClientRect();
              const touch = e.touches[0];
              const x = touch.clientX - rect.left;
              const y = touch.clientY - rect.top;
              const zoomScale = 2.5;
              activeImage.style.transform = `scale(${zoomScale}) translate(${(rect.width / 2 - x) / zoomScale}px, ${(rect.height / 2 - y) / zoomScale}px)`;
              currentScale2 = zoomScale;
            }
          }
        } else {
          lastTouchTime = now;
        }
      }
    }, { passive: false });
    viewport.addEventListener("touchmove", (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const distance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        const scale = Math.max(1, Math.min(4, currentScale * (distance / initialDistance)));
        const activeImage = this.images[this._currentIndex];
        if (activeImage) {
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
          const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
          const translateX = (rect.width / 2 - centerX) / scale;
          const translateY = (rect.height / 2 - centerY) / scale;
          activeImage.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
        }
      }
    }, { passive: false });
    viewport.addEventListener("touchend", () => {
      initialDistance = 0;
    });
  }
  goToSlide(index) {
    if (index < 0 || index >= this.images.length) return;
    this._currentIndex = index;
    this.images.forEach((img, i) => {
      if (i === index) {
        img.classList.add("afs-slider__image--active");
      } else {
        img.classList.remove("afs-slider__image--active");
      }
    });
    const activeImage = this.images[this._currentIndex];
    if (activeImage) {
      activeImage.classList.remove("afs-slider__image--zoomed");
      activeImage.classList.add("afs-slider__image--zoom-reset");
      setTimeout(() => {
        activeImage.classList.remove("afs-slider__image--zoom-reset");
      }, 200);
    }
    this.thumbnails.forEach((thumb, i) => {
      thumb.classList.toggle("afs-slider__thumbnail--active", i === index);
    });
    if (this.options.enableAutoHeight) {
      this.adjustHeight();
    }
    this.container.dispatchEvent(new CustomEvent("afs-slider:slide-change", {
      detail: { index, total: this.images.length }
    }));
  }
  prevSlide() {
    const newIndex = this._currentIndex > 0 ? this._currentIndex - 1 : this.images.length - 1;
    this.goToSlide(newIndex);
  }
  nextSlide() {
    const newIndex = this._currentIndex < this.images.length - 1 ? this._currentIndex + 1 : 0;
    this.goToSlide(newIndex);
  }
  adjustHeight() {
    const activeImage = this.images[this._currentIndex];
    if (!activeImage) return;
    if (activeImage.complete) {
      this.setHeight(activeImage);
    } else {
      activeImage.addEventListener("load", () => {
        this.setHeight(activeImage);
      }, { once: true });
    }
  }
  setHeight(image) {
    if (!this.mainContainer) return;
    const viewport = this.mainContainer.querySelector(".afs-slider__viewport");
    if (!viewport) return;
    if (this.options.maxHeight) {
      viewport.style.height = `${this.options.maxHeight}px`;
      viewport.style.minHeight = `${this.options.maxHeight}px`;
      viewport.style.maxHeight = `${this.options.maxHeight}px`;
      return;
    }
    const imgHeight = image.naturalHeight || image.offsetHeight;
    const imgWidth = image.naturalWidth || image.offsetWidth;
    const containerWidth = this.mainContainer.offsetWidth;
    const aspectRatio = imgHeight / imgWidth;
    const calculatedHeight = containerWidth * aspectRatio;
    viewport.style.height = `${calculatedHeight}px`;
    viewport.style.minHeight = `${calculatedHeight}px`;
  }
  /**
   * Update slider to show variant's image
   * @param variant - Variant object with image property
   * @param productImages - Array of product image URLs
   * @param allVariants - Optional: Array of all product variants for variant_ids optimization
   * @returns Returns true if image was found and updated, false otherwise
   */
  updateVariantImage(variant, productImages, allVariants) {
    var _a;
    if (!variant || !productImages || !Array.isArray(productImages) || productImages.length === 0) {
      return false;
    }
    const currentVariantId = variant.id;
    if (allVariants && Array.isArray(allVariants)) {
      if (variant.featured_image && typeof variant.featured_image === "object" && variant.featured_image.variant_ids) {
        const variantImagePosition2 = variant.featured_image.position;
        if (variantImagePosition2 !== null && variantImagePosition2 !== void 0) {
          const positionIndex = variantImagePosition2 - 1;
          if (positionIndex >= 0 && positionIndex < this.images.length && positionIndex < productImages.length) {
            if (this._currentIndex !== positionIndex) {
              this.goToSlide(positionIndex);
              return true;
            }
            return true;
          }
        }
      }
      for (const v of allVariants) {
        if (v.featured_image && typeof v.featured_image === "object" && v.featured_image.variant_ids) {
          if (v.featured_image.variant_ids.includes(Number(currentVariantId))) {
            const variantImagePosition2 = v.featured_image.position;
            if (variantImagePosition2 !== null && variantImagePosition2 !== void 0) {
              const positionIndex = variantImagePosition2 - 1;
              if (positionIndex >= 0 && positionIndex < this.images.length && positionIndex < productImages.length) {
                if (this._currentIndex !== positionIndex) {
                  this.goToSlide(positionIndex);
                  return true;
                }
                return true;
              }
            }
          }
        }
      }
    }
    let variantImageUrl = null;
    let variantImagePosition = null;
    if (variant.featured_image) {
      if (typeof variant.featured_image === "object") {
        variantImageUrl = variant.featured_image.src || variant.featured_image.url || null;
        variantImagePosition = (_a = variant.featured_image.position) != null ? _a : null;
      } else if (typeof variant.featured_image === "string") {
        variantImageUrl = variant.featured_image;
      }
    }
    if (!variantImageUrl) {
      if (typeof variant.image === "string") {
        variantImageUrl = variant.image;
      } else if (variant.image && typeof variant.image === "object") {
        variantImageUrl = variant.image.url || variant.image.src || null;
      } else if (variant.imageUrl) {
        variantImageUrl = variant.imageUrl;
      } else if (variant.featuredImage && typeof variant.featuredImage === "object") {
        variantImageUrl = variant.featuredImage.url || variant.featuredImage.src || null;
      }
    }
    if (!variantImageUrl) {
      return false;
    }
    const normalizeUrl = (url) => {
      if (!url) return "";
      const urlString = typeof url === "string" ? url : (url == null ? void 0 : url.url) || (url == null ? void 0 : url.src) || "";
      return urlString.replace(/^https?:\/\//, "").replace(/^\/\//, "").split("?")[0].toLowerCase().trim();
    };
    const normalizedVariantImage = normalizeUrl(variantImageUrl);
    if (variantImagePosition !== null && variantImagePosition !== void 0) {
      const positionIndex = variantImagePosition - 1;
      if (positionIndex >= 0 && positionIndex < this.images.length && positionIndex < productImages.length) {
        if (this._currentIndex !== positionIndex) {
          this.goToSlide(positionIndex);
          return true;
        }
        return true;
      }
    }
    let variantImageIndex = productImages.findIndex((img) => {
      const normalizedImg = normalizeUrl(img);
      return normalizedImg === normalizedVariantImage || normalizedImg.includes(normalizedVariantImage) || normalizedVariantImage.includes(normalizedImg);
    });
    if (variantImageIndex === -1) {
      const variantImageFilename = normalizedVariantImage.split("/").pop();
      variantImageIndex = productImages.findIndex((img) => {
        const imgFilename = normalizeUrl(img).split("/").pop();
        return imgFilename === variantImageFilename;
      });
    }
    if (variantImageIndex !== -1 && variantImageIndex < this.images.length) {
      if (this._currentIndex !== variantImageIndex) {
        this.goToSlide(variantImageIndex);
        return true;
      }
      return true;
    }
    return false;
  }
  destroy() {
    if (this.keyboardHandler) {
      document.removeEventListener("keydown", this.keyboardHandler);
      this.keyboardHandler = null;
    }
    this.images.forEach((img) => {
      img.classList.remove("afs-slider__image--zoomed");
      img.classList.add("afs-slider__image--zoom-reset");
      setTimeout(() => {
        img.classList.remove("afs-slider__image--zoom-reset");
      }, 200);
    });
    this.isInitialized = false;
  }
};
async function createProductModal(handle, modalId) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const dialog = $.el("dialog", "afs-product-modal", { "id": modalId });
  const loadingText = ((_b = (_a = Lang) == null ? void 0 : _a.labels) == null ? void 0 : _b.loadingProduct) || "Loading product...";
  dialog.innerHTML = `
	  <div class="afs-product-modal__container">
		<div class="afs-product-modal__close-container">
		  <button class="afs-product-modal__close" type="button">${Icons.close}</button>
		</div>
		<div class="afs-product-modal__content">
		  <div class="afs-product-modal__loading" style="padding: 2rem; text-align: center;">
			${loadingText}
		  </div>
		</div>
	  </div>
	`;
  const routesRoot = AFSW.Shopify && AFSW.Shopify.routes && AFSW.Shopify.routes.root || "/";
  const productUrl = `${routesRoot}products/${handle}.js`;
  try {
    const response = await fetch(productUrl);
    if (!response.ok) {
      const errorText = await response.text().catch(() => "");
      const errorMsg = `Failed to load product: HTTP ${response.status} ${response.statusText}${errorText ? " - " + errorText.substring(0, 100) : ""}`;
      Log.error("Product fetch failed", { status: response.status, statusText: response.statusText, url: productUrl, errorText });
      throw new Error(errorMsg);
    }
    const productData = await response.json();
    if (!productData.variants || !Array.isArray(productData.variants)) {
      throw new Error("Invalid product data structure");
    }
    const selectedVariant = productData.variants.find((v) => isVariantAvailable(v)) || productData.variants[0];
    let currentVariantId = selectedVariant ? selectedVariant.id : null;
    const buildVariantSelector = () => {
      if (!productData.variants || productData.variants.length === 0) return "";
      if (productData.variants.length === 1) {
        const firstVariant = productData.variants[0];
        const variantTitle = firstVariant.title;
        if (variantTitle && $.equals(variantTitle, "Default Title" /* DEFAULT_TITLE */)) {
          return "";
        }
      }
      if (!productData.options || productData.options.length === 0) return "";
      let html = '<div class="afs-product-modal__variant-selector">';
      productData.options.forEach((option, optionIndex) => {
        var _a2;
        html += `<div class="afs-product-modal__option-group">`;
        html += `<label class="afs-product-modal__option-label">${option.name}</label>`;
        html += `<div class="afs-product-modal__option-values">`;
        const uniqueValues = [...new Set(productData.variants.map((v) => {
          if (optionIndex === 0) return v.option1;
          if (optionIndex === 1) return v.option2;
          return v.option3;
        }).filter(Boolean))];
        const selectedOptions = Array.from({ length: ((_a2 = productData.options) == null ? void 0 : _a2.length) || 0 }, (_, idx) => {
          if (idx === optionIndex) return null;
          if (!selectedVariant) return null;
          if (idx === 0) return selectedVariant.option1 || null;
          if (idx === 1) return selectedVariant.option2 || null;
          return selectedVariant.option3 || null;
        });
        uniqueValues.forEach((value) => {
          if (!value) return;
          const isAvailable = isOptionValueAvailable(productData, optionIndex, value, selectedOptions);
          const isSelected = selectedVariant && (optionIndex === 0 && selectedVariant.option1 === value || optionIndex === 1 && selectedVariant.option2 === value || optionIndex === 2 && selectedVariant.option3 === value);
          const variant = productData.variants.find((v) => {
            if (optionIndex === 0) return v.option1 === value;
            if (optionIndex === 1) return v.option2 === value;
            return v.option3 === value;
          });
          html += `<button 
			  class="afs-product-modal__option-value ${isSelected ? "afs-product-modal__option-value--selected" : ""} ${!isAvailable ? "afs-product-modal__option-value--unavailable" : ""}"
			  data-option-index="${optionIndex}"
			  data-option-value="${value}"
			  data-variant-id="${variant ? variant.id : ""}"
			  ${!isAvailable ? "disabled" : ""}
			  type="button"
			>${value}</button>`;
        });
        html += `</div></div>`;
      });
      html += "</div>";
      return html;
    };
    const buildImagesHTML = () => {
      if (!productData.images || productData.images.length === 0) {
        return {
          thumbnails: "",
          mainImages: '<div class="afs-slider__main"><div style="padding: 2rem; text-align: center;">No images available</div></div>'
        };
      }
      let thumbnailsHTML = '<div class="afs-slider__thumbnails">';
      productData.images.forEach((image, index) => {
        const isActive = index === 0 ? "afs-slider__thumbnail--active" : "";
        const thumbnailUrl = $.optimizeImageUrl(image, {
          width: 100,
          height: 100,
          crop: "center",
          format: "webp",
          quality: 75
        });
        const thumbnailSizes = [80, 100, 120];
        const thumbnailSrcset = thumbnailSizes.map((size) => {
          const optimized = $.optimizeImageUrl(image, {
            width: size,
            height: size,
            crop: "center",
            format: "webp",
            quality: 75
          });
          return `${optimized} ${size}w`;
        }).join(", ");
        thumbnailsHTML += `
			<div class="afs-slider__thumbnail ${isActive}" data-slide-index="${index}">
			  <img 
				src="${thumbnailUrl}" 
				srcset="${thumbnailSrcset}"
				sizes="100px"
				alt="${productData.title} - Thumbnail ${index + 1}" 
				loading="lazy"
				width="100"
				height="100"
			  />
			</div>
		  `;
      });
      thumbnailsHTML += "</div>";
      let mainImagesHTML = '<div class="afs-slider__main">';
      productData.images.forEach((image, index) => {
        const mainImageUrl = $.optimizeImageUrl(image, {
          width: 800,
          height: 800,
          // Max height, will maintain aspect ratio
          format: "webp",
          quality: 85
          // No crop parameter = maintains aspect ratio
        });
        const mainImageSizes = [400, 600, 800, 1e3, 1200];
        const mainImageSrcset = mainImageSizes.map((size) => {
          const optimized = $.optimizeImageUrl(image, {
            width: size,
            height: size,
            format: "webp",
            quality: size <= 600 ? 80 : 85
            // No crop = maintains aspect ratio
          });
          return `${optimized} ${size}w`;
        }).join(", ");
        mainImagesHTML += `
			<img 
			  class="afs-slider__image" 
			  src="${mainImageUrl}" 
			  srcset="${mainImageSrcset}"
			  sizes="(max-width: 768px) 100vw, (max-width: 1024px) 50vw, 600px"
			  alt="${productData.title} - Image ${index + 1}" 
			  loading="${index === 0 ? "eager" : "lazy"}"
			/>
		  `;
      });
      mainImagesHTML += "</div>";
      return {
        thumbnails: thumbnailsHTML,
        mainImages: mainImagesHTML
      };
    };
    const imagesHTML = buildImagesHTML();
    const variantSelectorHTML = buildVariantSelector();
    const formatPrice2 = (price) => {
      return $.formatMoney(price, FilterState.moneyFormat || "{{amount}}", FilterState.currency || "");
    };
    const currentVariant = productData.variants.find((v) => v.id === currentVariantId) || selectedVariant;
    const priceHTML = formatPrice2(currentVariant.price);
    const comparePriceHTML = currentVariant.compare_at_price && currentVariant.compare_at_price > currentVariant.price ? `<span class="afs-product-modal__compare-price">${formatPrice2(currentVariant.compare_at_price)}</span>` : "";
    dialog.innerHTML = `
		<div class="afs-product-modal__container">
		  <div class="afs-product-modal__close-container">
			<button class="afs-product-modal__close" type="button">${Icons.close}</button>
		  </div>
		  <div class="afs-product-modal__content">
			<div class="afs-product-modal__layout">
			  <div class="afs-product-modal__media">
				<div class="afs-slider" id="${modalId}-slider">
				  ${imagesHTML.mainImages}
				  ${imagesHTML.thumbnails}
				</div>
			  </div>
			  <div class="afs-product-modal__details">
				<div class="afs-product-modal__header">
				  <div>
					<span class="afs-product-modal__vendor">${productData.vendor || ""}</span>
				  </div>
				  <h1 class="afs-product-modal__title">${productData.title || ""}</h1>
				  <div class="afs-product-modal__price-container">
					<span class="afs-product-modal__price">${priceHTML}</span>
					${comparePriceHTML}
				  </div>
				</div>
				${variantSelectorHTML}
				<div class="afs-product-modal__buttons">
				  <div class="afs-product-modal__add-to-cart">
					<div class="afs-product-modal__incrementor">
					  <button class="afs-product-modal__decrease" type="button">${Icons.minus}</button>
					  <span class="afs-product-modal__count" id="${modalId}-count">1</span>
					  <button class="afs-product-modal__increase" type="button">${Icons.plus}</button>
					</div>
					<button
					  class="afs-product-modal__add-button"
					  id="${modalId}-add-button"
					  data-variant-id="${currentVariantId}"
					  ${!isVariantAvailable(currentVariant) ? "disabled" : ""}
					  type="button"
					>
					  ${!isVariantAvailable(currentVariant) ? ((_d = (_c = Lang) == null ? void 0 : _c.buttons) == null ? void 0 : _d.soldOut) || "Sold out" : ((_f = (_e = Lang) == null ? void 0 : _e.buttons) == null ? void 0 : _f.addToCart) || "Add to cart"}
					</button>
				  </div>
				  <button
					class="afs-product-modal__buy-button"
					id="${modalId}-buy-button"
					data-variant-id="${currentVariantId}"
					${!isVariantAvailable(currentVariant) ? "disabled" : ""}
					type="button"
				  >
					${((_h = (_g = Lang) == null ? void 0 : _g.buttons) == null ? void 0 : _h.buyNow) || "Buy it now"}
				  </button>
				</div>
				<div class="afs-product-modal__description">
				  <span class="afs-product-modal__description-text">
					${productData.description || ""}
				  </span>
				</div>
			  </div>
			</div>
		  </div>
		</div>
	  `;
    dialog._productData = productData;
    dialog._currentVariantId = currentVariantId || void 0;
    (async () => {
      try {
        const sliderContainer = await waitForElement(`#${modalId}-slider`, dialog, 3e3);
        const images = await waitForElements(
          Array.from({ length: 10 }, (_, i) => `.afs-slider__image:nth-child(${i + 1})`),
          sliderContainer,
          2e3
        ).catch(() => {
          return Array.from(sliderContainer.querySelectorAll(".afs-slider__image"));
        });
        await waitForElement(".afs-slider__thumbnails", sliderContainer, 1e3).catch(() => {
          Log.warn("Thumbnails container not found, slider will continue without thumbnails", { modalId });
        });
        if (images.length > 0) {
          dialog._slider = new AFSSlider(sliderContainer, {
            thumbnailsPosition: "left",
            // Can be 'top', 'left', 'right', 'bottom'
            enableKeyboard: true,
            enableAutoHeight: false,
            // Disable auto height to prevent shrinking
            maxHeight: 600,
            // Fixed max height in pixels
            enableMagnifier: true,
            // Enable image magnifier on hover
            magnifierZoom: 2
            // 2x zoom level for magnifier
          });
        } else {
          Log.warn("No images found for slider", { modalId });
        }
      } catch (error) {
        Log.error("Failed to initialize slider", {
          error: error instanceof Error ? error.message : String(error),
          modalId
        });
      }
    })();
    setupModalHandlers(dialog, modalId, productData, formatPrice2);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const errorDetails = error instanceof Error ? { message: errorMessage, stack: error.stack } : { message: errorMessage };
    Log.error("Failed to load product for modal", {
      error: errorDetails,
      handle,
      productUrl,
      responseStatus: error instanceof Error && "status" in error ? error.status : void 0
    });
    const userMessage = ((_j = (_i = Lang) == null ? void 0 : _i.messages) == null ? void 0 : _j.failedToLoadProductModal) || "Failed to load product. Please try again.";
    dialog.innerHTML = `
		<div class="afs-product-modal__container">
		  <div class="afs-product-modal__close-container">
			<button class="afs-product-modal__close" type="button">${Icons.close}</button>
		  </div>
		  <div class="afs-product-modal__content">
			<div style="padding: 2rem; text-align: center;">
			  <p>${userMessage}</p>
			  ${Log.enabled ? `<p style="font-size: 0.875rem; color: #666; margin-top: 0.5rem;">Error: ${errorMessage}</p>` : ""}
			</div>
		  </div>
		</div>
	  `;
    const closeBtn = dialog.querySelector(".afs-product-modal__close");
    const closeModal = () => {
      if (dialog._slider && typeof dialog._slider.destroy === "function") {
        dialog._slider.destroy();
        dialog._slider = void 0;
      }
      document.body.style.overflow = "";
      document.body.style.removeProperty("overflow");
      if (dialog.close) {
        dialog.close();
      } else {
        dialog.style.display = "none";
      }
    };
    if (closeBtn) {
      closeBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        closeModal();
      });
    }
    dialog.addEventListener("cancel", closeModal);
    dialog.addEventListener("click", (e) => {
      if (e.target === dialog) {
        closeModal();
      }
    });
  }
  return dialog;
}
function setupModalHandlers(dialog, modalId, product, formatPrice2) {
  const closeBtn = dialog.querySelector(".afs-product-modal__close");
  const closeModal = () => {
    if (dialog._slider && typeof dialog._slider.destroy === "function") {
      dialog._slider.destroy();
      dialog._slider = void 0;
    }
    document.body.style.overflow = "";
    document.body.style.removeProperty("overflow");
    if (dialog.close) {
      dialog.close();
    } else {
      dialog.style.display = "none";
    }
  };
  if (closeBtn) {
    closeBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      closeModal();
    });
  }
  dialog.addEventListener("cancel", (e) => {
    e.preventDefault();
    closeModal();
  });
  dialog.addEventListener("click", (e) => {
    if (e.target === dialog) {
      closeModal();
    }
  });
  const decreaseBtn = dialog.querySelector(".afs-product-modal__decrease");
  const increaseBtn = dialog.querySelector(".afs-product-modal__increase");
  const countDisplay = dialog.querySelector(`#${modalId}-count`);
  if (decreaseBtn && countDisplay) {
    decreaseBtn.addEventListener("click", () => {
      const currentCount = parseInt(countDisplay.textContent || "1", 10) || 1;
      if (currentCount > 1) {
        countDisplay.textContent = String(currentCount - 1);
      }
    });
  }
  if (increaseBtn && countDisplay) {
    increaseBtn.addEventListener("click", () => {
      const currentCount = parseInt(countDisplay.textContent || "1", 10) || 1;
      countDisplay.textContent = String(currentCount + 1);
    });
  }
  const variantButtons = dialog.querySelectorAll(".afs-product-modal__option-value");
  variantButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      if (btn.disabled) return;
      const optionIndex = Number(btn.dataset.optionIndex);
      const optionValue = btn.dataset.optionValue;
      const selected = getSelectedOptions(dialog, product.options.length);
      selected[optionIndex] = optionValue;
      dialog.querySelectorAll(
        `.afs-product-modal__option-value[data-option-index="${optionIndex}"]`
      ).forEach((b) => b.classList.remove("afs-product-modal__option-value--selected"));
      btn.classList.add("afs-product-modal__option-value--selected");
      dialog.querySelectorAll(".afs-product-modal__option-value").forEach((b) => {
        const idx = Number(b.dataset.optionIndex);
        const val = b.dataset.optionValue;
        const available = isOptionValueAvailable(product, idx, val, selected);
        b.disabled = !available;
        b.classList.toggle(
          "afs-product-modal__option-value--unavailable",
          !available
        );
      });
      const matches = findMatchingVariants(product.variants, selected);
      const availableVariant = matches.find((v) => isVariantAvailable(v));
      const selectedVariant = availableVariant || matches[0];
      if (selectedVariant) {
        if (!dialog._slider) {
          const waitForSlider = (attempts = 0) => {
            if (dialog._slider) {
              updateVariantInModal(dialog, modalId, selectedVariant, formatPrice2);
            } else if (attempts < 20) {
              setTimeout(() => waitForSlider(attempts + 1), 100);
            } else {
              Log.warn("Slider not ready for variant update", { modalId });
              updateVariantInModal(dialog, modalId, selectedVariant, formatPrice2);
            }
          };
          waitForSlider();
        } else {
          updateVariantInModal(dialog, modalId, selectedVariant, formatPrice2);
        }
      } else {
        Log.warn("No matching variant found for selected options", {
          selected: selected.filter(Boolean),
          matchesCount: matches.length
        });
      }
    });
  });
  const addButton = dialog.querySelector(`#${modalId}-add-button`);
  if (addButton && countDisplay) {
    addButton.addEventListener("click", async () => {
      var _a, _b;
      if (addButton.disabled) return;
      const quantity = parseInt(countDisplay.textContent || "1", 10) || 1;
      const variantId = addButton.dataset.variantId;
      try {
        await QuickAdd.addVariant(parseInt(variantId || "0", 10), quantity);
        closeModal();
      } catch (error) {
        Log.error("Failed to add to cart from modal", { error: error instanceof Error ? error.message : String(error) });
        DOM.showError(((_b = (_a = Lang) == null ? void 0 : _a.messages) == null ? void 0 : _b.failedToAddToCart) || "Failed to add product to cart. Please try again.");
      }
    });
  }
  const buyButton = dialog.querySelector(`#${modalId}-buy-button`);
  if (buyButton && countDisplay) {
    buyButton.addEventListener("click", async () => {
      var _a, _b;
      if (buyButton.disabled) return;
      const quantity = parseInt(countDisplay.textContent || "1", 10) || 1;
      const variantId = buyButton.dataset.variantId;
      try {
        const routesRoot = AFSW.Shopify && AFSW.Shopify.routes && AFSW.Shopify.routes.root || "/";
        window.location.href = `${routesRoot}cart/${variantId}:${quantity}?checkout`;
      } catch (error) {
        Log.error("Failed to buy now", { error: error instanceof Error ? error.message : String(error) });
        DOM.showError(((_b = (_a = Lang) == null ? void 0 : _a.messages) == null ? void 0 : _b.failedToProceedToCheckout) || "Failed to proceed to checkout. Please try again.");
      }
    });
  }
}
function updateVariantInModal(dialog, modalId, variant, formatPrice2) {
  var _a, _b, _c, _d;
  dialog._currentVariantId = variant.id;
  const priceContainer = dialog.querySelector(".afs-product-modal__price-container");
  if (priceContainer) {
    const priceHTML = formatPrice2(variant.price);
    const comparePriceHTML = variant.compare_at_price && variant.compare_at_price > variant.price ? `<span class="afs-product-modal__compare-price">${formatPrice2(variant.compare_at_price)}</span>` : "";
    priceContainer.innerHTML = `
        <span class="afs-product-modal__price">${priceHTML}</span>
        ${comparePriceHTML}
      `;
  }
  const addButton = dialog.querySelector(`#${modalId}-add-button`);
  if (addButton) {
    const variantAvailable = isVariantAvailable(variant);
    addButton.dataset.variantId = String(variant.id);
    addButton.disabled = !variantAvailable;
    addButton.innerHTML = !variantAvailable ? ((_b = (_a = Lang) == null ? void 0 : _a.buttons) == null ? void 0 : _b.soldOut) || "Sold out" : ((_d = (_c = Lang) == null ? void 0 : _c.buttons) == null ? void 0 : _d.addToCart) || "Add to cart";
  }
  const buyButton = dialog.querySelector(`#${modalId}-buy-button`);
  if (buyButton) {
    const variantAvailable = isVariantAvailable(variant);
    buyButton.dataset.variantId = String(variant.id);
    buyButton.disabled = !variantAvailable;
  }
  const product = dialog._productData;
  if (product && product.images && product.variants) {
    if (!dialog._slider) {
      Log.debug("Slider not ready, skipping image update", { variantId: variant.id });
      return;
    }
    const currentVariantId = variant.id;
    let targetImageIndex = null;
    if (variant.featured_image && typeof variant.featured_image === "object" && variant.featured_image.variant_ids) {
      const variantImagePosition2 = variant.featured_image.position;
      if (variantImagePosition2 !== null && variantImagePosition2 !== void 0) {
        const positionIndex = variantImagePosition2 - 1;
        if (positionIndex >= 0 && positionIndex < product.images.length) {
          const currentSlideIndex = dialog._slider.currentIndex || 0;
          if (currentSlideIndex !== positionIndex) {
            targetImageIndex = positionIndex;
          }
        }
      }
    } else {
      for (const v of product.variants) {
        if (v.featured_image && typeof v.featured_image === "object" && v.featured_image.variant_ids) {
          if (v.featured_image.variant_ids.includes(Number(currentVariantId))) {
            const variantImagePosition2 = v.featured_image.position;
            if (variantImagePosition2 !== null && variantImagePosition2 !== void 0) {
              const positionIndex = variantImagePosition2 - 1;
              if (positionIndex >= 0 && positionIndex < product.images.length) {
                const currentSlideIndex = dialog._slider.currentIndex || 0;
                if (currentSlideIndex !== positionIndex) {
                  targetImageIndex = positionIndex;
                  break;
                }
              }
            }
          }
        }
      }
    }
    if (targetImageIndex !== null && dialog._slider.goToSlide) {
      dialog._slider.goToSlide(targetImageIndex);
      return;
    }
    if (dialog._slider.updateVariantImage && product.images) {
      const updated = dialog._slider.updateVariantImage(variant, product.images, product.variants);
      if (updated) return;
    }
    let variantImageUrl = null;
    let variantImagePosition = null;
    if (variant.featured_image) {
      if (typeof variant.featured_image === "object") {
        variantImageUrl = variant.featured_image.src || variant.featured_image.url || null;
        variantImagePosition = variant.featured_image.position || null;
      } else if (typeof variant.featured_image === "string") {
        variantImageUrl = variant.featured_image;
      }
    }
    if (!variantImageUrl) {
      variantImageUrl = (typeof variant.image === "string" ? variant.image : null) || variant.imageUrl || (variant.image && typeof variant.image === "object" ? variant.image.url || variant.image.src || null : null) || (variant.featuredImage && typeof variant.featuredImage === "object" ? variant.featuredImage.url || variant.featuredImage.src || null : null);
    }
    if (variantImageUrl && product.images && dialog._slider.goToSlide) {
      const normalizeUrl = (url) => {
        if (!url) return "";
        const urlString = typeof url === "string" ? url : url && typeof url === "object" ? url.url || url.src || "" : "";
        return urlString.replace(/^https?:\/\//, "").replace(/^\/\//, "").split("?")[0].toLowerCase().trim();
      };
      if (variantImagePosition !== null && variantImagePosition !== void 0) {
        const positionIndex = variantImagePosition - 1;
        if (positionIndex >= 0 && positionIndex < product.images.length) {
          dialog._slider.goToSlide(positionIndex);
          return;
        }
      }
      const normalizedVariantImage = normalizeUrl(variantImageUrl);
      const variantImageIndex = product.images.findIndex((img) => {
        const normalizedImg = normalizeUrl(img);
        return normalizedImg === normalizedVariantImage || normalizedImg.includes(normalizedVariantImage) || normalizedVariantImage.includes(normalizedImg);
      });
      if (variantImageIndex !== -1) {
        dialog._slider.goToSlide(variantImageIndex);
      } else {
        const variantImageFilename = normalizedVariantImage.split("/").pop();
        if (variantImageFilename) {
          const filenameMatchIndex = product.images.findIndex((img) => {
            const imgFilename = normalizeUrl(img).split("/").pop();
            return imgFilename === variantImageFilename;
          });
          if (filenameMatchIndex !== -1 && dialog._slider.goToSlide) {
            dialog._slider.goToSlide(filenameMatchIndex);
          }
        }
      }
    }
  }
}
function createQuickViewButton(product) {
  var _a, _b;
  if (!product.handle) return null;
  const ariaLabel = ((_b = (_a = Lang) == null ? void 0 : _a.buttons) == null ? void 0 : _b.quickView) || "Quick view";
  const quickViewBtn = $.el("button", "afs-product-card__quick-view", {
    "data-product-handle": product.handle,
    "data-product-id": String(product.id || product.productId || product.gid || ""),
    "aria-label": ariaLabel,
    "type": "button"
  });
  const quickViewIcon = $.el("span", "afs-product-card__quick-view-icon");
  quickViewIcon.innerHTML = Icons.eye;
  quickViewBtn.appendChild(quickViewIcon);
  return quickViewBtn;
}
function handleQuickViewClick(handle) {
  if (!handle) return;
  const modalId = `product-modal-${handle}`;
  let modal = document.getElementById(modalId);
  const openModal = async () => {
    if (!modal) {
      modal = await createProductModal(handle, modalId);
      document.body.appendChild(modal);
    }
    if (modal.showModal) {
      document.body.style.overflow = "hidden";
      modal.showModal();
    } else {
      document.body.style.overflow = "hidden";
      modal.style.display = "block";
    }
    const restoreScroll = () => {
      document.body.style.overflow = "";
      document.body.style.removeProperty("overflow");
    };
    modal.addEventListener("close", restoreScroll, { once: true });
    const observer = new MutationObserver(() => {
      if (modal && !modal.open && !modal.hasAttribute("open")) {
        restoreScroll();
        observer.disconnect();
      }
    });
    if (modal) {
      observer.observe(modal, { attributes: true, attributeFilter: ["open"] });
    }
  };
  openModal().catch((error) => {
    var _a, _b;
    const errorMessage = error instanceof Error ? error.message : String(error);
    Log.error("Failed to open product modal", { error: errorMessage, handle, stack: error instanceof Error ? error.stack : void 0 });
    const userMessage = ((_b = (_a = Lang) == null ? void 0 : _a.messages) == null ? void 0 : _b.failedToLoadProductModal) || "Failed to load product. Please try again.";
    if (DOM && typeof DOM.showError === "function") {
      DOM.showError(userMessage);
    } else {
      alert(userMessage);
    }
  });
}
var AFSW = window;
if (typeof window !== "undefined") {
  AFSW.AFS = AFS;
  AFSW.AFS_State = FilterState;
} else if (typeof global !== "undefined") {
  global.AFS = AFS;
}
